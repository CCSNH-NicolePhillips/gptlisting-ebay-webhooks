<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>SmartDrafts - Dropbox</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:24px;color:#111;max-width:1040px}
  input[type=text]{width:100%;padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:16px}
  select{width:100%;padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:16px;background:#fff}
    button{padding:8px 14px;border:1px solid #111;border-radius:8px;cursor:pointer;background:#111;color:#fff;font-weight:600}
    button:disabled{opacity:.5;cursor:not-allowed}
    .muted{color:#666;font-size:15px}
    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(320px,1fr));gap:16px;margin-top:16px}
    .card{border:1px solid #eee;border-radius:12px;padding:12px;background:#fff;box-shadow:0 1px 2px rgba(17,17,17,0.05)}
    .thumbs{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}
    .thumbs img{width:64px;height:64px;object-fit:cover;border:1px solid #eee;border-radius:8px;background:#f5f5f5}
    .panel{border:1px solid #ececec;border-radius:12px;padding:16px;margin:18px 0;background:#fafafa}
    .panel h2{margin:0 0 8px;font-size:20px}
    .panel p{margin:4px 0 12px}
    header{margin-bottom:18px}
    header h1{margin:0 0 6px;font-size:26px}
    .controls{margin:12px 0;display:flex;gap:8px;flex-wrap:wrap}
  label.group-toggle{display:flex;align-items:center;gap:6px;font-weight:600;font-size:15px}
  h3{margin:28px 0 12px;font-size:20px}
  .bullet-list{margin:8px 0;padding-left:18px;color:#444;font-size:14px}
  .bullet-list li{margin:0}
  .gpt-meta{margin-top:8px;font-size:14px;color:#444}
    .raw{white-space:pre-wrap;word-break:break-word;background:#111;color:#f5f5f5;padding:12px;border-radius:8px;font-size:13px;max-height:320px;overflow:auto}
    details{margin-top:8px;border:1px solid #ececec;border-radius:8px;padding:8px 10px;background:#f8f8f8}
    details summary{cursor:pointer;font-weight:600}
    table{width:100%;border-collapse:collapse;margin-top:8px;font-size:13px}
    table th,table td{border:1px solid #ddd;padding:6px 8px;text-align:left}
    table th{background:#f5f5f5}
    .debug-note{color:#666;font-size:14px;margin:8px 0}
    </style>
  </head>
  <body>
    <script src="/auth-client.js"></script>
    <script>
      try { window.authClient?.requireAuth?.(); } catch {}
    </script>

    <header>
      <h1>SmartDrafts - Dropbox Ingest</h1>
      <p class="muted">We pre-fill the Dropbox folder you selected on the Connect page. Scan it or pick another folder from the dropdown to build SmartDraft groups.</p>
    </header>

    <div class="panel">
      <h2>Pick a Dropbox folder</h2>
      <p class="muted">We load your Dropbox folders, defaulting to the path saved on the Connect page. Change the selection to scan a different folder.</p>
      <select id="folderSelect"></select>
      <div class="controls">
        <button id="btnScanFolder">Scan Folder</button>
        <button id="btnRescanFolder" style="background:#555;">Force Rescan</button>
        <label class="muted" style="display:flex;align-items:center;gap:6px;">
          <input id="includeDebug" type="checkbox" />
          Include debug output
        </label>
      </div>
      <div style="margin:12px 0; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
        <input id="defaultBrand" type="text" placeholder="Default Brand (optional)" style="width:260px;" autocomplete="off" />
        <input id="keywords" type="text" placeholder="Keywords (comma separated, optional)" style="width:320px;" autocomplete="off" />
        <button id="btnGenerate">Generate with GPT</button>
      </div>
      <div class="muted" id="folderInfo"></div>
    </div>

    <div id="status" class="muted"></div>
    <div id="warnings" class="muted"></div>
    <div id="grid" class="grid"></div>

  <h3 id="orphansTitle" style="display:none;">Unsorted Images</h3>
  <div id="orphansInfo" class="muted" style="display:none;"></div>
  <div id="orphansGrid" class="grid" style="display:none;"></div>

  <h3>Debug Details</h3>
  <div id="debugNote" class="muted debug-note">Enable debug output to inspect candidate scoring.</div>
  <div id="debugGrid" class="grid"></div>

  <h3>Raw Response</h3>
  <div class="controls" style="margin-top:0;">
    <button id="btnCopyRaw" type="button" disabled>Copy JSON</button>
  </div>
  <pre id="rawOutput" class="raw">Run a scan to populate this section.</pre>

    <h3>GPT Results</h3>
    <div id="gptStatus" class="muted"></div>
    <div id="gptGrid" class="grid"></div>

    <script type="module">
      const $ = (sel) => document.querySelector(sel);
      function el(tag, attrs = {}, children = []) {
        const node = document.createElement(tag);
        Object.entries(attrs).forEach(([key, value]) => {
          if (value === null || value === undefined || value === false) return;
          if (key === 'text') {
            node.textContent = String(value);
            return;
          }
          if (key === 'html') {
            node.innerHTML = String(value);
            return;
          }
          node.setAttribute(key, String(value === true ? '' : value));
        });
        children.forEach((child) => {
          if (child === null || child === undefined) return;
          if (typeof child === 'string') {
            node.appendChild(document.createTextNode(child));
          } else {
            node.appendChild(child);
          }
        });
        return node;
      }
  const folderSelect = $('#folderSelect');
  const btnScanFolder = $('#btnScanFolder');
  const btnRescanFolder = $('#btnRescanFolder');
  const statusEl = $('#status');
  const warningsEl = $('#warnings');
  const grid = $('#grid');
  const orphansTitle = $('#orphansTitle');
  const orphansInfo = $('#orphansInfo');
  const orphansGrid = $('#orphansGrid');
  const folderInfo = $('#folderInfo');
  const defaultBrandInput = $('#defaultBrand');
  const keywordsInput = $('#keywords');
  const btnGenerate = $('#btnGenerate');
  const gptStatus = $('#gptStatus');
  const gptGrid = $('#gptGrid');
  const includeDebug = $('#includeDebug');
  const debugNote = $('#debugNote');
  const debugGrid = $('#debugGrid');
  const rawOutput = $('#rawOutput');
  const btnCopyRaw = $('#btnCopyRaw');

      async function ensureAuth() {
        try {
          const ok = await (window.authClient?.ensureAuth?.() ?? Promise.resolve(false));
          return !!ok;
        } catch {
          return false;
        }
      }

      function getStoredFolder() {
        try {
          return localStorage.getItem('dbxDefaultFolder') || '';
        } catch {
          return '';
        }
      }

      function setStatus(message) {
        if (statusEl) statusEl.textContent = message || '';
      }

      function setWarnings(list) {
        if (!warningsEl) return;
        const hasWarnings = Array.isArray(list) && list.length > 0;
        if (!hasWarnings) {
          warningsEl.textContent = '';
          warningsEl.style.display = 'none';
          return;
        }
        warningsEl.style.display = 'block';
        warningsEl.innerHTML = list
          .map((warning) => `<div>â€¢ ${String(warning).replace(/[<>]/g, '')}</div>`)
          .join('');
      }

      async function fetchSmartDraftGroups(payload) {
        const exec = window.authClient?.authFetch ?? fetch;
        const body = JSON.stringify(payload);
        const res = await exec('/.netlify/functions/smartdrafts-scan', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body,
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok || !data?.ok) {
          const errMsg = data?.error || `Scan failed (${res.status})`;
          throw new Error(errMsg);
        }
        return data;
      }

  let isScanning = false;
  let isGenerating = false;
  let lastScanResult = null;

      function clearGptResults() {
        if (gptGrid) gptGrid.innerHTML = '';
        if (gptStatus) gptStatus.textContent = '';
        window._gptDrafts = [];
      }

      function updateGenerateState() {
        if (!btnGenerate) return;
        const groups = Array.isArray(window.smartDraftGroups) ? window.smartDraftGroups : [];
        btnGenerate.disabled = isGenerating || !groups.length;
      }

      function getSelectedGroupIds() {
        const nodes = Array.from(document.querySelectorAll('input[type=checkbox][data-pick]:checked'));
        return nodes
          .map((node) =>
            node instanceof HTMLInputElement ? node.value || node.getAttribute('data-group-id') || '' : ''
          )
          .map((value) => String(value || '').trim())
          .filter((value) => value.length > 0);
      }

      function dedupeStrings(list) {
        return Array.from(
          new Set(
            (Array.isArray(list) ? list : [])
              .filter((entry) => typeof entry === 'string')
              .map((entry) => entry.trim())
              .filter(Boolean),
          ),
        );
      }
      function renderOrphans(orphans) {
        if (!orphansGrid) return;
        const list = Array.isArray(orphans) ? orphans : [];
        window.smartDraftOrphans = list;
        orphansGrid.innerHTML = '';
        if (!list.length) {
          if (orphansTitle) orphansTitle.style.display = 'none';
          if (orphansInfo) {
            orphansInfo.style.display = 'none';
            orphansInfo.textContent = '';
          }
          orphansGrid.style.display = 'none';
          return;
        }
        if (orphansTitle) orphansTitle.style.display = 'block';
        if (orphansInfo) {
          orphansInfo.style.display = 'block';
          orphansInfo.textContent = `${list.length} image${list.length === 1 ? '' : 's'} could not be matched to a product.`;
        }
        orphansGrid.style.display = 'grid';
        list.forEach((item) => {
          const card = el('div', { class: 'card' });
          if (item?.url) {
            const img = el('img', { src: item.url, alt: item?.name || 'unsorted image', style: 'width:100%;max-width:260px;border-radius:8px;border:1px solid #eee;background:#f5f5f5;' });
            card.appendChild(img);
          }
          card.appendChild(
            el('div', {
              class: 'muted',
              html: `<strong>${item?.name || 'Image'}</strong>${item?.folder ? ` <span class="muted">(${item.folder})</span>` : ''}`,
            }),
          );
          orphansGrid.appendChild(card);
        });
      }

      function setRawOutput(value, allowCopy = false) {
        if (!rawOutput) return;
        if (value === null || value === undefined) {
          rawOutput.textContent = 'Run a scan to populate this section.';
          if (btnCopyRaw) btnCopyRaw.disabled = true;
          return;
        }
        const text = typeof value === 'string' ? value : JSON.stringify(value, null, 2);
        rawOutput.textContent = text;
        if (btnCopyRaw) btnCopyRaw.disabled = !allowCopy;
      }

      function renderDebugData(debugPayload, emptyMessage) {
        if (!debugGrid || !debugNote) return;
        debugGrid.innerHTML = '';
        if (!includeDebug || !includeDebug.checked) {
          debugNote.textContent = 'Enable debug output to inspect candidate scoring.';
          debugNote.style.display = 'block';
          return;
        }
        if (!debugPayload || !Array.isArray(debugPayload.groups) || !debugPayload.groups.length) {
          debugNote.textContent = emptyMessage || 'Run a scan with debug enabled to see candidate scoring.';
          debugNote.style.display = 'block';
          return;
        }
        debugNote.style.display = 'none';
        debugPayload.groups.forEach((entry, index) => {
          const card = el('div', { class: 'card' });
          const heading = document.createElement('h4');
          heading.textContent = entry?.name || entry?.groupId || `Group ${index + 1}`;
          card.appendChild(heading);

          const clipMeta = debugPayload.clip || {};
          const clipPieces = [
            clipMeta.enabled ? 'enabled' : 'disabled',
            `provider ${clipMeta.provider ?? 'hf'}`,
            `model ${clipMeta.model ?? 'n/a'}`,
            `text ${clipMeta.textDim ?? 0}`,
            `img ${clipMeta.imgDim ?? 0}`,
            `weight ${clipMeta.weight ?? 'â€”'}`,
            `min sim ${clipMeta.minSimilarity ?? 'â€”'}`,
          ];
          if (clipMeta.error) {
            clipPieces.push(`error ${clipMeta.error}`);
          }
          card.appendChild(
            el('div', {
              class: 'muted',
              text: `CLIP ${clipPieces.join(' â€¢ ')} â€¢ MIN_ASSIGN ${debugPayload.minAssign}`,
            }),
          );

          const table = document.createElement('table');
          table.innerHTML = `
            <thead>
              <tr>
                <th>#</th>
                <th>Name</th>
                <th>Total</th>
                <th>Base</th>
                <th>CLIP</th>
                <th>Sim</th>
                <th>Assigned</th>
              </tr>
            </thead>
            <tbody></tbody>
          `;
          const tbody = table.querySelector('tbody');
          (Array.isArray(entry?.candidates) ? entry.candidates : []).forEach((candidate, idx) => {
            const row = document.createElement('tr');
            const cells = [
              idx + 1,
              candidate?.name || '(image)',
              Number(candidate?.total ?? 0).toFixed(2),
              Number(candidate?.base ?? 0).toFixed(2),
              Number(candidate?.clipContribution ?? 0).toFixed(2),
              candidate?.clipSimilarity === null || candidate?.clipSimilarity === undefined
                ? 'â€”'
                : Number(candidate.clipSimilarity).toFixed(3),
              candidate?.assigned ? 'yes' : 'no',
            ];
            cells.forEach((value) => {
              const cell = document.createElement('td');
              cell.textContent = String(value);
              row.appendChild(cell);
            });
            tbody?.appendChild(row);
          });
          card.appendChild(table);

          const detailsEl = document.createElement('details');
          const summary = document.createElement('summary');
          summary.textContent = 'Show candidate JSON';
          const pre = document.createElement('pre');
          pre.className = 'raw';
          pre.style.background = '#f4f4f4';
          pre.style.color = '#222';
          pre.style.maxHeight = '200px';
          pre.textContent = JSON.stringify(entry?.candidates || [], null, 2);
          detailsEl.appendChild(summary);
          detailsEl.appendChild(pre);
          card.appendChild(detailsEl);

          debugGrid.appendChild(card);
        });
      }


      function parseGroupName(name) {
        const raw = String(name || '').replace(/_/g, ' ').replace(/\s+/g, ' ').trim();
        if (!raw) return { product: 'Product', variant: undefined, size: undefined };
        let working = raw;
        let variant;
        const parenMatch = raw.match(/\(([^)]+)\)\s*$/);
        if (parenMatch) {
          variant = parenMatch[1].trim();
          working = raw.slice(0, -parenMatch[0].length).trim();
        }
        if (!variant) {
          const split = working.split(/\s*[|:/â€“â€”-]\s*/);
          if (split.length > 1) {
            variant = split.pop()?.trim();
            working = split.join(' - ').trim();
          }
        }
        const sizeMatch = raw.match(/(\d+(?:\.\d+)?\s?(?:oz|fl oz|g|kg|lb|lbs|ml|ct|count|pack|pk))/i);
        const size = sizeMatch ? sizeMatch[0].replace(/\s+/g, ' ').trim() : undefined;
        if (variant && size && variant.toLowerCase() === size.toLowerCase()) {
          variant = undefined;
        }
        const product = working || raw;
        return { product, variant, size };
      }

      function collectFolderFeatures(group) {
        const features = [];
        const folder = typeof group?.folder === 'string' ? group.folder : '';
        if (folder) {
          const parts = folder.split('/').filter(Boolean);
          parts.slice(-3).forEach((part) => features.push(part));
        }
        return dedupeStrings(features).slice(0, 10);
      }

      function makeSeedsFromGroups(groups) {
        const brandOverride = (defaultBrandInput?.value || '').trim() || undefined;
        const keywordRaw = (keywordsInput?.value || '').trim();
        const keywordList = keywordRaw
          ? dedupeStrings(keywordRaw.split(',').map((entry) => entry.trim())).slice(0, 12)
          : [];
        return groups.map((group) => {
          const parsed = parseGroupName(group?.name || group?.product || group?.folder || 'Product');
          const variant = (typeof group?.variant === 'string' && group.variant.trim()) || parsed.variant;
          const size = (typeof group?.size === 'string' && group.size.trim()) || parsed.size;
          const productName =
            (typeof group?.product === 'string' && group.product.trim()) || parsed.product || group?.name || 'Product';
          const brand = brandOverride || (typeof group?.brand === 'string' && group.brand.trim()) || undefined;
          const features = [
            ...collectFolderFeatures(group),
            ...(Array.isArray(group?.claims) ? group.claims : []),
            ...(Array.isArray(group?.features) ? group.features : []),
          ];
          if (variant) features.push(variant);
          if (size) features.push(size);
          if (group?.category?.title) features.push(group.category.title);
          const mergedFeatures = dedupeStrings(features).slice(0, 12);
          return {
            id: group?.groupId,
            brand,
            product: productName,
            variant,
            size,
            features: mergedFeatures,
            keywords: keywordList,
            folder: typeof group?.folder === 'string' ? group.folder : undefined,
            groupName: typeof group?.name === 'string' ? group.name : undefined,
          };
        });
      }

      function renderGptDrafts(drafts) {
        if (!gptGrid) return;
        gptGrid.innerHTML = '';
        if (!Array.isArray(drafts) || !drafts.length) {
          return;
        }
        drafts.forEach((draft) => {
          const card = el('div', { class: 'card' });
          const checkboxAttrs = {
            type: 'checkbox',
            value: draft?.id || '',
            'data-gpt-pick': draft?.id || '',
          };
          if (!String(draft?.description || '').startsWith('ERROR')) {
            checkboxAttrs.checked = 'checked';
          }
          const toggle = el('label', { class: 'group-toggle' }, [el('input', checkboxAttrs), 'Use draft']);
          card.appendChild(toggle);

          const titleWrap = document.createElement('div');
          const strong = document.createElement('strong');
          strong.textContent = (draft?.title || '').slice(0, 80);
          titleWrap.appendChild(strong);
          card.appendChild(titleWrap);

          const bullets = Array.isArray(draft?.bullets) ? draft.bullets : [];
          if (bullets.length) {
            const bulletList = document.createElement('ul');
            bulletList.className = 'bullet-list';
            bullets.slice(0, 3).forEach((bullet) => {
              const li = document.createElement('li');
              li.textContent = bullet;
              bulletList.appendChild(li);
            });
            card.appendChild(bulletList);
          }

          if (draft?.description) {
            card.appendChild(el('div', { class: 'muted', text: String(draft.description) }));
          }

          const aspectEntries = Object.entries(draft?.aspects || {});
          const aspectsText = aspectEntries.length
            ? aspectEntries
                .map(([key, values]) => `${key}: ${(Array.isArray(values) ? values : []).join(', ')}`)
                .join(' | ')
            : '(none)';
          card.appendChild(el('div', { class: 'gpt-meta', text: `Aspects: ${aspectsText}` }));

          const catName = draft?.category?.name || '(suggested)';
          const catId = draft?.category?.id ? ` (${draft.category.id})` : '';
          card.appendChild(el('div', { class: 'gpt-meta', text: `Category: ${catName}${catId}` }));

          if (draft?.id) {
            card.appendChild(el('div', { class: 'gpt-meta', text: `Group ID: ${draft.id}` }));
          }

          gptGrid.appendChild(card);
        });
      }

      async function runScan(payload, description) {
        if (isScanning) return;
        isScanning = true;
        clearGptResults();
        window.smartDraftGroups = [];
        updateGenerateState();
        setStatus(description);
        setWarnings([]);
        grid.innerHTML = '';
        renderOrphans([]);
        lastScanResult = null;
  setRawOutput('Fetching response...');
  renderDebugData(null, 'Waiting for scan results...');
        try {
          const authed = await ensureAuth();
          if (!authed) {
            setStatus('Please sign in to scan Dropbox.');
            setRawOutput(null);
            renderDebugData(null, 'Sign in to request debug data.');
            return;
          }

          const payloadWithLimit = { ...payload, limit: 100 };
          if (payload.force) payloadWithLimit.force = true;
          if (includeDebug?.checked) payloadWithLimit.debug = true;

          const data = await fetchSmartDraftGroups(payloadWithLimit);
          lastScanResult = data;
          const groups = Array.isArray(data.groups) ? data.groups : [];
          window.smartDraftGroups = groups;
          updateGenerateState();
          const folder = data.folder || payload.path || '/';
          const cachedNote = data.cached ? ' (cached)' : '';
          const fallback = groups.some((group) => group && group._fallback);
          const baseMessage = `Found ${groups.length} product group${groups.length === 1 ? '' : 's'} in "${folder}"${cachedNote}.`;
          setStatus(fallback ? `${baseMessage} Vision fallback in use.` : baseMessage);
          setWarnings(Array.isArray(data.warnings) ? data.warnings : []);
          renderGroups(groups);
          renderOrphans(Array.isArray(data.orphans) ? data.orphans : []);
          renderDebugData(data.debug, 'No debug data returned.');
          setRawOutput(data, true);
        } catch (err) {
          const message = err?.message || String(err);
          setStatus(`Error: ${message}`);
          setWarnings([]);
          renderOrphans([]);
          lastScanResult = { ok: false, error: message };
          renderDebugData(null, 'Debug data unavailable for the last scan.');
          setRawOutput(lastScanResult, true);
        } finally {
          isScanning = false;
          updateGenerateState();
        }
      }

      function setStoredFolder(path) {
        try {
          localStorage.setItem('dbxDefaultFolder', path || '');
        } catch {}
      }

      async function loadFolders() {
        if (!folderSelect) return;
        folderSelect.disabled = true;
  folderSelect.innerHTML = '<option>Loading folders...</option>';
        try {
          const exec = window.authClient?.authFetch ?? fetch;
          const url = new URL('/.netlify/functions/dropbox-list-folders', window.location.origin);
          url.searchParams.set('recursive', '1');
          const res = await exec(url.toString());
          const data = await res.json();
          const entries = Array.isArray(data?.folders) ? data.folders : [];
          const unique = new Map();
          entries.forEach((entry) => {
            const path = entry?.path_display || entry?.path_lower || entry?.name || '';
            if (path) {
              unique.set(path, path);
            }
          });
          const options = Array.from(unique.keys()).sort((a, b) => a.localeCompare(b));
          const stored = getStoredFolder();
          folderSelect.innerHTML = '';
          options.forEach((path) => {
            const opt = document.createElement('option');
            opt.value = path;
            opt.textContent = path;
            folderSelect.appendChild(opt);
          });
          if (stored && options.includes(stored)) {
            folderSelect.value = stored;
          } else if (options.length) {
            folderSelect.value = options[0];
            setStoredFolder(options[0]);
          }
          folderSelect.disabled = false;
          const current = folderSelect.value || stored;
          if (folderInfo) {
            folderInfo.textContent = current
              ? `Selected folder: ${current}`
              : 'No folder selected.';
          }
          if (current) {
            setStatus(`Ready to scan ${current}.`);
          } else {
            setStatus('Select a Dropbox folder to scan.');
          }
        } catch (err) {
          folderSelect.innerHTML = '<option>Failed to load folders</option>';
          if (folderInfo) folderInfo.textContent = err?.message || 'Error loading folders';
          setStatus('Unable to load folders from Dropbox.');
        }
      }

      function renderGroups(groups) {
        grid.innerHTML = '';
        if (!groups.length) {
          updateGenerateState();
          return;
        }
        groups.forEach((group) => {
          const card = el('div', { class: 'card' });
          const checkbox = el('input', {
            type: 'checkbox',
            value: group.groupId,
            'data-group-id': group.groupId,
            'data-pick': group.groupId,
            checked: 'checked',
          });
          const toggle = el('label', { class: 'group-toggle' }, [checkbox, 'Use group']);
          card.appendChild(toggle);

          const titleParts = [`<strong>${group.name || '(unnamed)'}</strong>`];
          if (group.folder) {
            titleParts.push(`<span class="muted">${group.folder}</span>`);
          }
          card.appendChild(el('div', { html: titleParts.join(' ') }));

          const metaParts = [];
          if (group.brand) metaParts.push(`Brand: <code>${group.brand}</code>`);
          if (group.product && group.product !== group.name) metaParts.push(`Product: <code>${group.product}</code>`);
          if (group.variant) metaParts.push(`Variant: <code>${group.variant}</code>`);
          if (group.size) metaParts.push(`Size: <code>${group.size}</code>`);
          if (typeof group.confidence === 'number' && Number.isFinite(group.confidence)) {
            const pct = Math.round(group.confidence * 100);
            metaParts.push(`Confidence: ${pct}%`);
          }
          const categoryMeta = (() => {
            if (!group.category) return null;
            if (typeof group.category === 'string') {
              return { label: group.category, id: '' };
            }
            if (typeof group.category === 'object') {
              const label = group.category.title || group.category.name || '';
              const id = group.category.id ? ` (${group.category.id})` : '';
              if (label) return { label, id };
            }
            return null;
          })();
          if (categoryMeta) {
            metaParts.push(`Category: <code>${categoryMeta.label}${categoryMeta.id}</code>`);
          }
          if (group._fallback) metaParts.push('<span style="color:#a00">Vision fallback</span>');
          if (metaParts.length) {
            card.appendChild(el('div', { class: 'muted', html: metaParts.join(' â€¢ ') }));
          }

          const thumbs = el('div', { class: 'thumbs' });
          (Array.isArray(group.images) ? group.images : []).slice(0, 8).forEach((url) => {
            thumbs.appendChild(el('img', { src: url, alt: 'preview' }));
          });
          card.appendChild(thumbs);

          const claims = Array.isArray(group.claims) ? group.claims : [];
          if (claims.length) {
            const list = document.createElement('ul');
            list.className = 'bullet-list';
            claims.slice(0, 4).forEach((claim) => {
              const li = document.createElement('li');
              li.textContent = claim;
              list.appendChild(li);
            });
            card.appendChild(list);
          }

          grid.appendChild(card);
        });
        updateGenerateState();
      }

      includeDebug?.addEventListener('change', () => {
        if (!includeDebug.checked) {
          renderDebugData(null);
          return;
        }
        if (lastScanResult && typeof lastScanResult === 'object' && lastScanResult !== null && lastScanResult.debug) {
          renderDebugData(lastScanResult.debug, 'No debug data returned.');
        } else {
          renderDebugData(null, 'Run a scan with debug enabled to see candidate scoring.');
        }
      });

      btnCopyRaw?.addEventListener('click', async () => {
        if (!lastScanResult) return;
        const text = typeof lastScanResult === 'string'
          ? lastScanResult
          : JSON.stringify(lastScanResult, null, 2);
        try {
          if (!navigator.clipboard || typeof navigator.clipboard.writeText !== 'function') {
            throw new Error('Clipboard unavailable');
          }
          const previousStatus = statusEl?.textContent || '';
          await navigator.clipboard.writeText(text);
          if (statusEl) {
            statusEl.textContent = 'Copied raw response to clipboard.';
            setTimeout(() => {
              if (statusEl && statusEl.textContent === 'Copied raw response to clipboard.') {
                statusEl.textContent = previousStatus;
              }
            }, 2000);
          }
        } catch (error) {
          if (statusEl) statusEl.textContent = 'Unable to copy raw JSON (clipboard blocked).';
        }
      });

      btnGenerate?.addEventListener('click', async () => {
        if (isGenerating) return;
        const groups = Array.isArray(window.smartDraftGroups) ? window.smartDraftGroups : [];
        if (!groups.length) {
          if (gptStatus) gptStatus.textContent = 'Scan a Dropbox folder before generating.';
          return;
        }
        const selectedIds = getSelectedGroupIds();
        const selectedGroups = groups.filter((group) => selectedIds.includes(group.groupId));
        if (!selectedGroups.length) {
          if (gptStatus) gptStatus.textContent = 'Select at least one group above.';
          return;
        }
        isGenerating = true;
        updateGenerateState();
        clearGptResults();
  if (gptStatus) gptStatus.textContent = 'Generating with GPT...';
        try {
          const seeds = makeSeedsFromGroups(selectedGroups);
          const exec = window.authClient?.authFetch ?? fetch;
          const res = await exec('/.netlify/functions/ai-gpt-drafts', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ seeds }),
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok || !data?.ok) {
            throw new Error(data?.error || `ai-gpt-drafts failed (${res.status})`);
          }
          const drafts = Array.isArray(data.drafts) ? data.drafts : [];
          window._gptDrafts = drafts;
          renderGptDrafts(drafts);
          if (gptStatus) gptStatus.textContent = `Generated ${drafts.length} draft(s).`;
        } catch (err) {
          if (gptStatus) gptStatus.textContent = `GPT error: ${err?.message || err}`;
        } finally {
          isGenerating = false;
          updateGenerateState();
        }
      });
      btnScanFolder?.addEventListener('click', () => {
        const path = (folderSelect?.value || '').trim();
        if (!path) {
          setStatus('Select a Dropbox folder first.');
          return;
        }
        setStoredFolder(path);
        if (folderInfo) folderInfo.textContent = `Selected folder: ${path}`;
  runScan({ path }, `Scanning ${path}...`);
      });

      btnRescanFolder?.addEventListener('click', () => {
        const path = (folderSelect?.value || '').trim();
        if (!path) {
          setStatus('Select a Dropbox folder first.');
          return;
        }
        setStoredFolder(path);
        if (folderInfo) folderInfo.textContent = `Selected folder: ${path}`;
  runScan({ path, force: true }, `Rescanning ${path} (forcing refresh)...`);
      });

      folderSelect?.addEventListener('change', () => {
        const path = (folderSelect.value || '').trim();
        if (path) {
          setStoredFolder(path);
          if (folderInfo) folderInfo.textContent = `Selected folder: ${path}`;
          setStatus(`Ready to scan ${path}.`);
        }
      });

  updateGenerateState();
  setWarnings([]);
  renderDebugData(null);
  setRawOutput(null);

      (async () => {
        const authed = await ensureAuth();
        if (!authed) {
          setStatus('Please sign in to load Dropbox folders.');
          return;
        }
        await loadFolders();
      })();
    </script>
  </body>
</html>
