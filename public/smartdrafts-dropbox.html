<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>SmartDrafts - Dropbox</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:24px;color:#111;max-width:1040px}
  input[type=text]{width:100%;padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:16px}
  select{width:100%;padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:16px;background:#fff}
    button{padding:8px 14px;border:1px solid #111;border-radius:8px;cursor:pointer;background:#111;color:#fff;font-weight:600}
    button:disabled{opacity:.5;cursor:not-allowed}
    .muted{color:#666;font-size:15px}
    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(320px,1fr));gap:16px;margin-top:16px}
    .card{border:1px solid #eee;border-radius:12px;padding:12px;background:#fff;box-shadow:0 1px 2px rgba(17,17,17,0.05)}
  .thumbs{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}
  .thumb{position:relative}
  .thumbs img{width:64px;height:64px;object-fit:cover;border:1px solid #eee;border-radius:8px;background:#f5f5f5}
  .thumb-badge{position:absolute;left:4px;bottom:4px;padding:2px 4px;border-radius:6px;background:rgba(17,17,17,0.82);color:#fff;font-size:11px;font-weight:600;text-transform:uppercase;letter-spacing:.02em}
  .thumb-badge.secondary{background:rgba(34,102,221,0.82)}
  .thumb-badge.back{background:rgba(17,17,17,0.72)}
  .thumb-badge.supporting{background:rgba(85,85,85,0.78)}
    .panel{border:1px solid #ececec;border-radius:12px;padding:16px;margin:18px 0;background:#fafafa}
    .panel h2{margin:0 0 8px;font-size:20px}
    .panel p{margin:4px 0 12px}
    header{margin-bottom:18px}
    header h1{margin:0 0 6px;font-size:26px}
    .controls{margin:12px 0;display:flex;gap:8px;flex-wrap:wrap}
  label.group-toggle{display:flex;align-items:center;gap:6px;font-weight:600;font-size:15px}
  h3{margin:28px 0 12px;font-size:20px}
  .bullet-list{margin:8px 0;padding-left:18px;color:#444;font-size:14px}
  .bullet-list li{margin:0}
  .gpt-meta{margin-top:8px;font-size:14px;color:#444}
    .raw{white-space:pre-wrap;word-break:break-word;background:#111;color:#f5f5f5;padding:12px;border-radius:8px;font-size:13px;max-height:320px;overflow:auto}
    details{margin-top:8px;border:1px solid #ececec;border-radius:8px;padding:8px 10px;background:#f8f8f8}
    details summary{cursor:pointer;font-weight:600}
    table{width:100%;border-collapse:collapse;margin-top:8px;font-size:13px}
    table th,table td{border:1px solid #ddd;padding:6px 8px;text-align:left}
    table th{background:#f5f5f5}
    .debug-note{color:#666;font-size:14px;margin:8px 0}
    </style>
  </head>
  <body>
    <script src="/auth-client.js"></script>
    <script>
      try { window.authClient?.requireAuth?.(); } catch {}
    </script>

    <header>
      <h1>SmartDrafts - Dropbox Ingest</h1>
      <p class="muted">We pre-fill the Dropbox folder you selected on the Connect page. Scan it or pick another folder from the dropdown to build SmartDraft groups.</p>
    </header>

    <div class="panel">
      <h2>Pick a Dropbox folder</h2>
      <p class="muted">We load your Dropbox folders, defaulting to the path saved on the Connect page. Change the selection to scan a different folder.</p>
      <select id="folderSelect"></select>
      <div class="controls">
        <button id="btnScanFolder">Scan Folder</button>
        <button id="btnRescanFolder" style="background:#555;">Force Rescan</button>
        <label class="muted" style="display:flex;align-items:center;gap:6px;">
          <input id="includeDebug" type="checkbox" />
          Include debug output
        </label>
      </div>
      <div style="margin:12px 0; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
        <input id="defaultBrand" type="text" placeholder="Default Brand (optional)" style="width:260px;" autocomplete="off" />
        <input id="keywords" type="text" placeholder="Keywords (comma separated, optional)" style="width:320px;" autocomplete="off" />
        <button id="btnGenerate">Generate with GPT</button>
      </div>
      <div class="muted" id="folderInfo"></div>
    </div>

    <div id="status" class="muted"></div>
    <div id="warnings" class="muted"></div>
    <div id="grid" class="grid"></div>

  <!-- Pairing & Draft Generation Section -->
  <div id="pairingSection" class="panel" style="display:none; margin-top:24px;">
    <h2>Create Listings</h2>
    <p class="muted">Pair products and generate eBay-ready listings with ChatGPT.</p>
    <div class="controls">
      <button id="btnPairProducts">1. Pair Products</button>
      <button id="btnCreateDrafts" disabled style="background:#2266dd;">2. Generate Listings</button>
    </div>
    <div id="pairingStatus" class="muted" style="margin-top:8px;"></div>
  </div>

  <!-- Paired Products Display -->
  <div id="pairedProductsSection" style="display:none; margin-top:24px;">
    <h3>Paired Products</h3>
    <div id="pairedProductsGrid" class="grid"></div>
  </div>

  <!-- Generated Drafts Display -->
  <div id="draftsSection" style="display:none; margin-top:24px;">
    <h3>Generated Listings</h3>
    <div id="draftsGrid" class="grid"></div>
  </div>

  <h3 id="orphansTitle" style="display:none;">Unsorted Images</h3>
  <div id="orphansInfo" class="muted" style="display:none;"></div>
  <div id="orphansGrid" class="grid" style="display:none;"></div>

  <h3>Debug Details</h3>
  <div id="debugNote" class="muted debug-note">Enable debug output to inspect candidate scoring.</div>
  <div id="debugGrid" class="grid"></div>

  <h3>Raw Response</h3>
  <div class="controls" style="margin-top:0;">
    <button id="btnCopyRaw" type="button" disabled>Copy JSON</button>
  </div>
  <pre id="rawOutput" class="raw">Run a scan to populate this section.</pre>

    <h3>GPT Results</h3>
    <div id="gptStatus" class="muted"></div>
    <div id="gptGrid" class="grid"></div>

    <script type="module">
      const $ = (sel) => document.querySelector(sel);
      function el(tag, attrs = {}, children = []) {
        const node = document.createElement(tag);
        Object.entries(attrs).forEach(([key, value]) => {
          if (value === null || value === undefined || value === false) return;
          if (key === 'text') {
            node.textContent = String(value);
            return;
          }
          if (key === 'html') {
            node.innerHTML = String(value);
            return;
          }
          node.setAttribute(key, String(value === true ? '' : value));
        });
        children.forEach((child) => {
          if (child === null || child === undefined) return;
          if (typeof child === 'string') {
            node.appendChild(document.createTextNode(child));
          } else {
            node.appendChild(child);
          }
        });
        return node;
      }
  const folderSelect = $('#folderSelect');
  const btnScanFolder = $('#btnScanFolder');
  const btnRescanFolder = $('#btnRescanFolder');
  const statusEl = $('#status');
  const warningsEl = $('#warnings');
  const grid = $('#grid');
  const orphansTitle = $('#orphansTitle');
  const orphansInfo = $('#orphansInfo');
  const orphansGrid = $('#orphansGrid');
  const folderInfo = $('#folderInfo');
  const defaultBrandInput = $('#defaultBrand');
  const keywordsInput = $('#keywords');
  const btnGenerate = $('#btnGenerate');
  const gptStatus = $('#gptStatus');
  const gptGrid = $('#gptGrid');
  const includeDebug = $('#includeDebug');
  const debugNote = $('#debugNote');
  const debugGrid = $('#debugGrid');
  const rawOutput = $('#rawOutput');
  const btnCopyRaw = $('#btnCopyRaw');

      async function ensureAuth() {
        try {
          const ok = await (window.authClient?.ensureAuth?.() ?? Promise.resolve(false));
          return !!ok;
        } catch {
          return false;
        }
      }

      function getStoredFolder() {
        try {
          return localStorage.getItem('dbxDefaultFolder') || '';
        } catch {
          return '';
        }
      }

      function setStatus(message) {
        if (statusEl) statusEl.textContent = message || '';
      }

      function setWarnings(list) {
        if (!warningsEl) return;
        const hasWarnings = Array.isArray(list) && list.length > 0;
        if (!hasWarnings) {
          warningsEl.textContent = '';
          warningsEl.style.display = 'none';
          return;
        }
        warningsEl.style.display = 'block';
        warningsEl.innerHTML = list
          .map((warning) => `<div>• ${String(warning).replace(/[<>]/g, '')}</div>`)
          .join('');
      }

      async function queueSmartDraftScan(payload) {
        const exec = window.authClient?.authFetch ?? fetch;
        const body = JSON.stringify(payload);
        const res = await exec('/.netlify/functions/smartdrafts-scan-bg', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body,
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok || !data?.ok || !data?.jobId) {
          const errMsg = data?.error || `Scan enqueue failed (${res.status})`;
          throw new Error(errMsg);
        }
        return String(data.jobId);
      }

      const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

      async function pollSmartDraftScan(jobId, { onUpdate, maxAttempts = 120 } = {}) {
        const exec = window.authClient?.authFetch ?? fetch;
        for (let attempt = 0; attempt < maxAttempts; attempt++) {
          const url = new URL('/.netlify/functions/smartdrafts-scan-status', window.location.origin);
          url.searchParams.set('jobId', jobId);
          const res = await exec(url.toString());
          const data = await res.json().catch(() => ({}));
          if (res.status === 404) {
            throw new Error('Scan job not found');
          }
          if (!res.ok) {
            throw new Error(data?.error || `Scan status failed (${res.status})`);
          }
          if (typeof onUpdate === 'function') {
            try { onUpdate(data); } catch {}
          }
          if (data?.state === 'complete' || data?.state === 'error') {
            return data;
          }
          const delay = Math.min(5000, 500 + attempt * 150);
          await sleep(delay);
        }
        throw new Error('Timed out waiting for SmartDrafts scan results.');
      }

  let isScanning = false;
  let isGenerating = false;
  let lastScanResult = null;

      function clearGptResults() {
        if (gptGrid) gptGrid.innerHTML = '';
        if (gptStatus) gptStatus.textContent = '';
        window._gptDrafts = [];
      }

      function updateGenerateState() {
        if (!btnGenerate) return;
        const groups = Array.isArray(window.smartDraftGroups) ? window.smartDraftGroups : [];
        btnGenerate.disabled = isGenerating || !groups.length;
      }

      function getSelectedGroupIds() {
        const nodes = Array.from(document.querySelectorAll('input[type=checkbox][data-pick]:checked'));
        return nodes
          .map((node) =>
            node instanceof HTMLInputElement ? node.value || node.getAttribute('data-group-id') || '' : ''
          )
          .map((value) => String(value || '').trim())
          .filter((value) => value.length > 0);
      }

      function dedupeStrings(list) {
        return Array.from(
          new Set(
            (Array.isArray(list) ? list : [])
              .filter((entry) => typeof entry === 'string')
              .map((entry) => entry.trim())
              .filter(Boolean),
          ),
        );
      }
      function renderOrphans(orphans) {
        if (!orphansGrid) return;
        const list = Array.isArray(orphans) ? orphans : [];
        window.smartDraftOrphans = list;
        orphansGrid.innerHTML = '';
        if (!list.length) {
          if (orphansTitle) orphansTitle.style.display = 'none';
          if (orphansInfo) {
            orphansInfo.style.display = 'none';
            orphansInfo.textContent = '';
          }
          orphansGrid.style.display = 'none';
          return;
        }
        if (orphansTitle) orphansTitle.style.display = 'block';
        if (orphansInfo) {
          orphansInfo.style.display = 'block';
          orphansInfo.textContent = `${list.length} image${list.length === 1 ? '' : 's'} could not be matched to a product.`;
        }
        orphansGrid.style.display = 'grid';
        list.forEach((item) => {
          const card = el('div', { class: 'card' });
          if (item?.url) {
            const img = el('img', { src: item.url, alt: item?.name || 'unsorted image', style: 'width:100%;max-width:260px;border-radius:8px;border:1px solid #eee;background:#f5f5f5;' });
            card.appendChild(img);
          }
          card.appendChild(
            el('div', {
              class: 'muted',
              html: `<strong>${item?.name || 'Image'}</strong>${item?.folder ? ` <span class="muted">(${item.folder})</span>` : ''}`,
            }),
          );
          orphansGrid.appendChild(card);
        });
      }

      function setRawOutput(value, allowCopy = false) {
        if (!rawOutput) return;
        if (value === null || value === undefined) {
          rawOutput.textContent = 'Run a scan to populate this section.';
          if (btnCopyRaw) btnCopyRaw.disabled = true;
          return;
        }
        const text = typeof value === 'string' ? value : JSON.stringify(value, null, 2);
        rawOutput.textContent = text;
        if (btnCopyRaw) btnCopyRaw.disabled = !allowCopy;
      }

      function renderDebugData(debugPayload, emptyMessage) {
        if (!debugGrid || !debugNote) return;
        debugGrid.innerHTML = '';
        if (!includeDebug || !includeDebug.checked) {
          debugNote.textContent = 'Enable debug output to inspect candidate scoring.';
          debugNote.style.display = 'block';
          return;
        }
        if (!debugPayload || !Array.isArray(debugPayload.groups) || !debugPayload.groups.length) {
          debugNote.textContent = emptyMessage || 'Run a scan with debug enabled to see candidate scoring.';
          debugNote.style.display = 'block';
          return;
        }
        debugNote.style.display = 'none';
        debugPayload.groups.forEach((entry, index) => {
          const card = el('div', { class: 'card' });
          const heading = document.createElement('h4');
          heading.textContent = entry?.name || entry?.groupId || `Group ${index + 1}`;
          card.appendChild(heading);

          const clipMeta = debugPayload.clip || {};
          const clipPieces = [
            clipMeta.enabled ? 'enabled' : 'disabled',
            `provider ${clipMeta.provider ?? 'hf'}`,
            `model ${clipMeta.model ?? 'n/a'}`,
            clipMeta.base ? `base ${clipMeta.base}` : null,
            clipMeta.textBase ? `text ${clipMeta.textBase}` : null,
            clipMeta.imageBase ? `image ${clipMeta.imageBase}` : null,
            `text ${clipMeta.textDim ?? 0}`,
            `img ${clipMeta.imgDim ?? 0}`,
            `weight ${clipMeta.weight ?? '—'}`,
            `min sim ${clipMeta.minSimilarity ?? '—'}`,
          ];
          if (clipMeta.error) {
            clipPieces.push(`error ${clipMeta.error}`);
          }
          card.appendChild(
            el('div', {
              class: 'muted',
              text: `CLIP ${clipPieces.filter(Boolean).join(' • ')} • MIN_ASSIGN ${debugPayload.minAssign}`,
            }),
          );

          const table = document.createElement('table');
          table.innerHTML = `
            <thead>
              <tr>
                <th>#</th>
                <th>Name</th>
                <th>Total</th>
                <th>Base</th>
                <th>CLIP</th>
                <th>Sim</th>
                <th>Assigned</th>
              </tr>
            </thead>
            <tbody></tbody>
          `;
          const tbody = table.querySelector('tbody');
          (Array.isArray(entry?.candidates) ? entry.candidates : []).forEach((candidate, idx) => {
            const row = document.createElement('tr');
            const cells = [
              idx + 1,
              candidate?.name || '(image)',
              Number(candidate?.total ?? 0).toFixed(2),
              Number(candidate?.base ?? 0).toFixed(2),
              Number(candidate?.clipContribution ?? 0).toFixed(2),
              candidate?.clipSimilarity === null || candidate?.clipSimilarity === undefined
                ? '—'
                : Number(candidate.clipSimilarity).toFixed(3),
              candidate?.assigned ? 'yes' : 'no',
            ];
            cells.forEach((value) => {
              const cell = document.createElement('td');
              cell.textContent = String(value);
              row.appendChild(cell);
            });
            tbody?.appendChild(row);
          });
          card.appendChild(table);

          const detailsEl = document.createElement('details');
          const summary = document.createElement('summary');
          summary.textContent = 'Show candidate JSON';
          const pre = document.createElement('pre');
          pre.className = 'raw';
          pre.style.background = '#f4f4f4';
          pre.style.color = '#222';
          pre.style.maxHeight = '200px';
          pre.textContent = JSON.stringify(entry?.candidates || [], null, 2);
          detailsEl.appendChild(summary);
          detailsEl.appendChild(pre);
          card.appendChild(detailsEl);

          debugGrid.appendChild(card);
        });
      }


      function parseGroupName(name) {
        const raw = String(name || '').replace(/_/g, ' ').replace(/\s+/g, ' ').trim();
        if (!raw) return { product: 'Product', variant: undefined, size: undefined };
        let working = raw;
        let variant;
        const parenMatch = raw.match(/\(([^)]+)\)\s*$/);
        if (parenMatch) {
          variant = parenMatch[1].trim();
          working = raw.slice(0, -parenMatch[0].length).trim();
        }
        if (!variant) {
          const split = working.split(/\s*[|:/–—-]\s*/);
          if (split.length > 1) {
            variant = split.pop()?.trim();
            working = split.join(' - ').trim();
          }
        }
        const sizeMatch = raw.match(/(\d+(?:\.\d+)?\s?(?:oz|fl oz|g|kg|lb|lbs|ml|ct|count|pack|pk))/i);
        const size = sizeMatch ? sizeMatch[0].replace(/\s+/g, ' ').trim() : undefined;
        if (variant && size && variant.toLowerCase() === size.toLowerCase()) {
          variant = undefined;
        }
        const product = working || raw;
        return { product, variant, size };
      }

      function collectFolderFeatures(group) {
        const features = [];
        const folder = typeof group?.folder === 'string' ? group.folder : '';
        if (folder) {
          const parts = folder.split('/').filter(Boolean);
          parts.slice(-3).forEach((part) => features.push(part));
        }
        return dedupeStrings(features).slice(0, 10);
      }

      function makeSeedsFromGroups(groups) {
        const brandOverride = (defaultBrandInput?.value || '').trim() || undefined;
        const keywordRaw = (keywordsInput?.value || '').trim();
        const keywordList = keywordRaw
          ? dedupeStrings(keywordRaw.split(',').map((entry) => entry.trim())).slice(0, 12)
          : [];
        return groups.map((group) => {
          const parsed = parseGroupName(group?.name || group?.product || group?.folder || 'Product');
          const variant = (typeof group?.variant === 'string' && group.variant.trim()) || parsed.variant;
          const size = (typeof group?.size === 'string' && group.size.trim()) || parsed.size;
          const productName =
            (typeof group?.product === 'string' && group.product.trim()) || parsed.product || group?.name || 'Product';
          const brand = brandOverride || (typeof group?.brand === 'string' && group.brand.trim()) || undefined;
          const optionHints = {};
          const features = [
            ...collectFolderFeatures(group),
            ...(Array.isArray(group?.claims) ? group.claims : []),
            ...(Array.isArray(group?.features) ? group.features : []),
          ];
          if (group?.options && typeof group.options === 'object') {
            Object.entries(group.options).forEach(([rawKey, rawValue]) => {
              const key = typeof rawKey === 'string' ? rawKey.trim() : '';
              if (!key) return;
              const values = Array.isArray(rawValue) ? rawValue : [rawValue];
              const normalized = dedupeStrings(
                values
                  .map((entry) => (entry === undefined || entry === null ? '' : String(entry).trim()))
                  .filter(Boolean)
              ).slice(0, 10);
              if (!normalized.length) return;
              optionHints[key] = normalized;
              normalized.forEach((value) => features.push(`${key}: ${value}`));
            });
          }
          if (variant) features.push(variant);
          if (size) features.push(size);
          if (group?.category?.title) features.push(group.category.title);
          const mergedFeatures = dedupeStrings(features).slice(0, 12);
          return {
            id: group?.groupId,
            brand,
            product: productName,
            variant,
            size,
            features: mergedFeatures,
            keywords: keywordList,
            options: Object.keys(optionHints).length ? optionHints : undefined,
            folder: typeof group?.folder === 'string' ? group.folder : undefined,
            groupName: typeof group?.name === 'string' ? group.name : undefined,
          };
        });
      }

      function derivePreferredImages(group) {
        const base = Array.isArray(group?.images) ? group.images : [];
        const hero = typeof group?.heroUrl === 'string' ? group.heroUrl : group?.primaryImageUrl;
        const back = typeof group?.backUrl === 'string' ? group.backUrl : null;
        const secondary = typeof group?.secondaryImageUrl === 'string' ? group.secondaryImageUrl : null;
        const supporting = Array.isArray(group?.supportingImageUrls)
          ? group.supportingImageUrls.filter((url) => typeof url === 'string' && url.length > 0)
          : [];
        const ordered = [hero, back, secondary, ...supporting];
        const seen = new Set();
        const result = [];
        const push = (url) => {
          if (!url || typeof url !== 'string') return;
          if (seen.has(url)) return;
          seen.add(url);
          result.push(url);
        };
        ordered.forEach((url) => push(url));
        base.forEach((url) => push(url));
        return result;
      }

      function imageRole(group, url) {
        if (!group || !url) return null;
        const match = (value) => typeof value === 'string' && value === url;
        if (match(group?.heroUrl) || match(group?.primaryImageUrl)) return 'hero';
        if (match(group?.backUrl)) return 'back';
        if (match(group?.secondaryImageUrl)) return 'secondary';
        if (Array.isArray(group?.supportingImageUrls) && group.supportingImageUrls.includes(url)) return 'supporting';
        return null;
      }

      function formatRoleLabel(role) {
        if (!role) return null;
        switch (role) {
          case 'hero':
            return 'Hero';
          case 'back':
            return 'Back';
          case 'secondary':
            return 'Alt';
          case 'supporting':
            return 'Support';
          default:
            return null;
        }
      }

      function renderGptDrafts(drafts) {
        if (!gptGrid) return;
        gptGrid.innerHTML = '';
        if (!Array.isArray(drafts) || !drafts.length) {
          return;
        }
        drafts.forEach((draft) => {
          const card = el('div', { class: 'card' });
          const checkboxAttrs = {
            type: 'checkbox',
            value: draft?.id || '',
            'data-gpt-pick': draft?.id || '',
          };
          if (!String(draft?.description || '').startsWith('ERROR')) {
            checkboxAttrs.checked = 'checked';
          }
          const toggle = el('label', { class: 'group-toggle' }, [el('input', checkboxAttrs), 'Use draft']);
          card.appendChild(toggle);

          const titleWrap = document.createElement('div');
          const strong = document.createElement('strong');
          strong.textContent = (draft?.title || '').slice(0, 80);
          titleWrap.appendChild(strong);
          card.appendChild(titleWrap);

          const bullets = Array.isArray(draft?.bullets) ? draft.bullets : [];
          if (bullets.length) {
            const bulletList = document.createElement('ul');
            bulletList.className = 'bullet-list';
            bullets.slice(0, 3).forEach((bullet) => {
              const li = document.createElement('li');
              li.textContent = bullet;
              bulletList.appendChild(li);
            });
            card.appendChild(bulletList);
          }

          if (draft?.description) {
            card.appendChild(el('div', { class: 'muted', text: String(draft.description) }));
          }

          const aspectEntries = Object.entries(draft?.aspects || {});
          const aspectsText = aspectEntries.length
            ? aspectEntries
                .map(([key, values]) => `${key}: ${(Array.isArray(values) ? values : []).join(', ')}`)
                .join(' | ')
            : '(none)';
          card.appendChild(el('div', { class: 'gpt-meta', text: `Aspects: ${aspectsText}` }));

          const catName = draft?.category?.name || '(suggested)';
          const catId = draft?.category?.id ? ` (${draft.category.id})` : '';
          card.appendChild(el('div', { class: 'gpt-meta', text: `Category: ${catName}${catId}` }));

          if (draft?.id) {
            card.appendChild(el('div', { class: 'gpt-meta', text: `Group ID: ${draft.id}` }));
          }

          gptGrid.appendChild(card);
        });
      }

      async function runScan(payload, description) {
        if (isScanning) return;
        isScanning = true;
        clearGptResults();
        window.smartDraftGroups = [];
        updateGenerateState();
        setStatus(description);
        setWarnings([]);
        grid.innerHTML = '';
        renderOrphans([]);
        lastScanResult = null;
  setRawOutput('Fetching response...');
  renderDebugData(null, 'Waiting for scan results...');
        try {
          const authed = await ensureAuth();
          if (!authed) {
            setStatus('Please sign in to scan Dropbox.');
            setRawOutput(null);
            renderDebugData(null, 'Sign in to request debug data.');
            return;
          }

          const payloadWithLimit = { ...payload, limit: 100 };
          if (payload.force) payloadWithLimit.force = true;
          if (includeDebug?.checked) payloadWithLimit.debug = true;

          const jobId = await queueSmartDraftScan(payloadWithLimit);
          setStatus(`Scan job ${jobId} queued. Waiting for results...`);

          const job = await pollSmartDraftScan(jobId, {
            onUpdate: (update) => {
              const state = String(update?.state || 'pending').toLowerCase();
              const note = update?.warnings?.length ? ` (${update.warnings.length} warning${update.warnings.length === 1 ? '' : 's'})` : '';
              setStatus(`Scan ${state}${note}...`);
            },
          });

          if (!job || job.state === 'error') {
            const message = job?.error || 'SmartDrafts scan failed';
            throw new Error(message);
          }

          const data = {
            ok: true,
            folder: job.folder || payload.path || '/',
            signature: job.signature ?? null,
            count: Number.isFinite(job.count) ? Number(job.count) : (Array.isArray(job.groups) ? job.groups.length : 0),
            warnings: Array.isArray(job.warnings) ? job.warnings : [],
            groups: Array.isArray(job.groups) ? job.groups : [],
            orphans: Array.isArray(job.orphans) ? job.orphans : [],
            cached: Boolean(job.cached),
            debug: job.debug,
          };

          lastScanResult = data;
          const groups = data.groups;
          window.smartDraftGroups = groups;
          updateGenerateState();
          const folder = data.folder || payload.path || '/';
          const cachedNote = data.cached ? ' (cached)' : '';
          const fallback = groups.some((group) => group && group._fallback);
          const baseMessage = `Found ${groups.length} product group${groups.length === 1 ? '' : 's'} in "${folder}"${cachedNote}.`;
          setStatus(fallback ? `${baseMessage} Vision fallback in use.` : baseMessage);
          setWarnings(data.warnings);
          renderGroups(groups);
          renderOrphans(Array.isArray(data.orphans) ? data.orphans : []);
          renderDebugData(data.debug, 'No debug data returned.');
          setRawOutput({ jobId, ...job }, true);
          
          // Save folder info for pairing and show pairing section
          window._lastScanData = { 
            folderUrl: folder, 
            folderPath: payload.path || folder 
          };
          showPairingSection();
        } catch (err) {
          const message = err?.message || String(err);
          setStatus(`Error: ${message}`);
          setWarnings([]);
          renderOrphans([]);
          lastScanResult = { ok: false, error: message };
          renderDebugData(null, 'Debug data unavailable for the last scan.');
          setRawOutput(lastScanResult, true);
        } finally {
          isScanning = false;
          updateGenerateState();
        }
      }

      function setStoredFolder(path) {
        try {
          localStorage.setItem('dbxDefaultFolder', path || '');
        } catch {}
      }

      async function loadFolders() {
        if (!folderSelect) return;
        folderSelect.disabled = true;
  folderSelect.innerHTML = '<option>Loading folders...</option>';
        try {
          const exec = window.authClient?.authFetch ?? fetch;
          const url = new URL('/.netlify/functions/dropbox-list-folders', window.location.origin);
          url.searchParams.set('recursive', '1');
          const res = await exec(url.toString());
          const data = await res.json();
          const entries = Array.isArray(data?.folders) ? data.folders : [];
          const unique = new Map();
          entries.forEach((entry) => {
            const path = entry?.path_display || entry?.path_lower || entry?.name || '';
            if (path) {
              unique.set(path, path);
            }
          });
          const options = Array.from(unique.keys()).sort((a, b) => a.localeCompare(b));
          const stored = getStoredFolder();
          folderSelect.innerHTML = '';
          options.forEach((path) => {
            const opt = document.createElement('option');
            opt.value = path;
            opt.textContent = path;
            folderSelect.appendChild(opt);
          });
          if (stored && options.includes(stored)) {
            folderSelect.value = stored;
          } else if (options.length) {
            folderSelect.value = options[0];
            setStoredFolder(options[0]);
          }
          folderSelect.disabled = false;
          const current = folderSelect.value || stored;
          if (folderInfo) {
            folderInfo.textContent = current
              ? `Selected folder: ${current}`
              : 'No folder selected.';
          }
          if (current) {
            setStatus(`Ready to scan ${current}.`);
          } else {
            setStatus('Select a Dropbox folder to scan.');
          }
        } catch (err) {
          folderSelect.innerHTML = '<option>Failed to load folders</option>';
          if (folderInfo) folderInfo.textContent = err?.message || 'Error loading folders';
          setStatus('Unable to load folders from Dropbox.');
        }
      }

      function renderGroups(groups) {
        grid.innerHTML = '';
        if (!groups.length) {
          updateGenerateState();
          return;
        }
        groups.forEach((group) => {
          const card = el('div', { class: 'card' });
          const checkbox = el('input', {
            type: 'checkbox',
            value: group.groupId,
            'data-group-id': group.groupId,
            'data-pick': group.groupId,
            checked: 'checked',
          });
          const toggle = el('label', { class: 'group-toggle' }, [checkbox, 'Use group']);
          card.appendChild(toggle);

          const titleParts = [`<strong>${group.name || '(unnamed)'}</strong>`];
          if (group.folder) {
            titleParts.push(`<span class="muted">${group.folder}</span>`);
          }
          card.appendChild(el('div', { html: titleParts.join(' ') }));

          const metaParts = [];
          if (group.brand) metaParts.push(`Brand: <code>${group.brand}</code>`);
          if (group.product && group.product !== group.name) metaParts.push(`Product: <code>${group.product}</code>`);
          if (group.variant) metaParts.push(`Variant: <code>${group.variant}</code>`);
          if (group.size) metaParts.push(`Size: <code>${group.size}</code>`);
          if (typeof group.confidence === 'number' && Number.isFinite(group.confidence)) {
            const pct = Math.round(group.confidence * 100);
            metaParts.push(`Confidence: ${pct}%`);
          }
          const categoryMeta = (() => {
            if (!group.category) return null;
            if (typeof group.category === 'string') {
              return { label: group.category, id: '' };
            }
            if (typeof group.category === 'object') {
              const label = group.category.title || group.category.name || '';
              const id = group.category.id ? ` (${group.category.id})` : '';
              if (label) return { label, id };
            }
            return null;
          })();
          if (categoryMeta) {
            metaParts.push(`Category: <code>${categoryMeta.label}${categoryMeta.id}</code>`);
          }
          if (group._fallback) metaParts.push('<span style="color:#a00">Vision fallback</span>');
          if (metaParts.length) {
            card.appendChild(el('div', { class: 'muted', html: metaParts.join(' • ') }));
          }

          const thumbs = el('div', { class: 'thumbs' });
          const previewImages = derivePreferredImages(group).slice(0, 8);
          if (!previewImages.length) {
            thumbs.appendChild(el('div', { class: 'muted', text: 'No images selected.' }));
          } else {
            previewImages.forEach((url) => {
              const role = imageRole(group, url);
              const label = formatRoleLabel(role);
              const badge = label ? el('span', { class: `thumb-badge ${role}`, text: label }) : null;
              const img = el('img', {
                src: url,
                alt: label ? `${label} preview` : 'preview',
                title: label ? `${label} image` : 'preview',
              });
              const children = badge ? [img, badge] : [img];
              thumbs.appendChild(el('div', { class: 'thumb' }, children));
            });
          }
          card.appendChild(thumbs);

          const claims = Array.isArray(group.claims) ? group.claims : [];
          if (claims.length) {
            const list = document.createElement('ul');
            list.className = 'bullet-list';
            claims.slice(0, 4).forEach((claim) => {
              const li = document.createElement('li');
              li.textContent = claim;
              list.appendChild(li);
            });
            card.appendChild(list);
          }

          grid.appendChild(card);
        });
        updateGenerateState();
      }

      includeDebug?.addEventListener('change', () => {
        if (!includeDebug.checked) {
          renderDebugData(null);
          return;
        }
        if (lastScanResult && typeof lastScanResult === 'object' && lastScanResult !== null && lastScanResult.debug) {
          renderDebugData(lastScanResult.debug, 'No debug data returned.');
        } else {
          renderDebugData(null, 'Run a scan with debug enabled to see candidate scoring.');
        }
      });

      btnCopyRaw?.addEventListener('click', async () => {
        if (!lastScanResult) return;
        const text = typeof lastScanResult === 'string'
          ? lastScanResult
          : JSON.stringify(lastScanResult, null, 2);
        try {
          if (!navigator.clipboard || typeof navigator.clipboard.writeText !== 'function') {
            throw new Error('Clipboard unavailable');
          }
          const previousStatus = statusEl?.textContent || '';
          await navigator.clipboard.writeText(text);
          if (statusEl) {
            statusEl.textContent = 'Copied raw response to clipboard.';
            setTimeout(() => {
              if (statusEl && statusEl.textContent === 'Copied raw response to clipboard.') {
                statusEl.textContent = previousStatus;
              }
            }, 2000);
          }
        } catch (error) {
          if (statusEl) statusEl.textContent = 'Unable to copy raw JSON (clipboard blocked).';
        }
      });

      btnGenerate?.addEventListener('click', async () => {
        if (isGenerating) return;
        const groups = Array.isArray(window.smartDraftGroups) ? window.smartDraftGroups : [];
        if (!groups.length) {
          if (gptStatus) gptStatus.textContent = 'Scan a Dropbox folder before generating.';
          return;
        }
        const selectedIds = getSelectedGroupIds();
        const selectedGroups = groups.filter((group) => selectedIds.includes(group.groupId));
        if (!selectedGroups.length) {
          if (gptStatus) gptStatus.textContent = 'Select at least one group above.';
          return;
        }
        isGenerating = true;
        updateGenerateState();
        clearGptResults();
  if (gptStatus) gptStatus.textContent = 'Generating with GPT...';
        try {
          const seeds = makeSeedsFromGroups(selectedGroups);
          const exec = window.authClient?.authFetch ?? fetch;
          const res = await exec('/.netlify/functions/ai-gpt-drafts', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ seeds }),
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok || !data?.ok) {
            throw new Error(data?.error || `ai-gpt-drafts failed (${res.status})`);
          }
          const drafts = Array.isArray(data.drafts) ? data.drafts : [];
          window._gptDrafts = drafts;
          renderGptDrafts(drafts);
          if (gptStatus) gptStatus.textContent = `Generated ${drafts.length} draft(s).`;
        } catch (err) {
          if (gptStatus) gptStatus.textContent = `GPT error: ${err?.message || err}`;
        } finally {
          isGenerating = false;
          updateGenerateState();
        }
      });
      btnScanFolder?.addEventListener('click', () => {
        const path = (folderSelect?.value || '').trim();
        if (!path) {
          setStatus('Select a Dropbox folder first.');
          return;
        }
        setStoredFolder(path);
        if (folderInfo) folderInfo.textContent = `Selected folder: ${path}`;
  runScan({ path }, `Scanning ${path}...`);
      });

      btnRescanFolder?.addEventListener('click', () => {
        const path = (folderSelect?.value || '').trim();
        if (!path) {
          setStatus('Select a Dropbox folder first.');
          return;
        }
        setStoredFolder(path);
        if (folderInfo) folderInfo.textContent = `Selected folder: ${path}`;
  runScan({ path, force: true }, `Rescanning ${path} (forcing refresh)...`);
      });

      folderSelect?.addEventListener('change', () => {
        const path = (folderSelect.value || '').trim();
        if (path) {
          setStoredFolder(path);
          if (folderInfo) folderInfo.textContent = `Selected folder: ${path}`;
          setStatus(`Ready to scan ${path}.`);
        }
      });

      // Pairing & Draft Creation
      let pairedProducts = [];
      const btnPairProducts = $('#btnPairProducts');
      const btnCreateDrafts = $('#btnCreateDrafts');
      const pairingSection = $('#pairingSection');
      const pairingStatus = $('#pairingStatus');
      const pairedProductsSection = $('#pairedProductsSection');
      const pairedProductsGrid = $('#pairedProductsGrid');
      const draftsSection = $('#draftsSection');
      const draftsGrid = $('#draftsGrid');

      function showPairingSection() {
        if (pairingSection) pairingSection.style.display = 'block';
      }

      btnPairProducts?.addEventListener('click', async () => {
        const folderUrl = window._lastScanData?.folderUrl || folderSelect?.value;
        if (!folderUrl) {
          if (pairingStatus) pairingStatus.textContent = 'Please scan a folder first.';
          return;
        }

        btnPairProducts.disabled = true;
        btnCreateDrafts.disabled = true;
        if (pairingStatus) pairingStatus.textContent = 'Pairing products...';
        
        try {
          const exec = window.authClient?.authFetch ?? fetch;
          const res = await exec('/.netlify/functions/smartdrafts-pairing', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ folder: folderUrl }),
          });
          
          const data = await res.json().catch(() => ({}));
          if (!res.ok || !data?.ok) {
            throw new Error(data?.error || `Pairing failed (${res.status})`);
          }
          
          pairedProducts = data.products || [];
          if (pairingStatus) {
            pairingStatus.textContent = `✅ Paired ${pairedProducts.length} product(s). Ready to generate listings.`;
          }
          btnCreateDrafts.disabled = false;
          
          // Display paired products
          renderPairedProducts(pairedProducts);
          
        } catch (err) {
          if (pairingStatus) {
            pairingStatus.textContent = `❌ Pairing error: ${err?.message || err}`;
          }
        } finally {
          btnPairProducts.disabled = false;
        }
      });

      btnCreateDrafts?.addEventListener('click', async () => {
        if (!pairedProducts.length) {
          if (pairingStatus) pairingStatus.textContent = 'Pair products first.';
          return;
        }

        btnCreateDrafts.disabled = true;
        btnPairProducts.disabled = true;
        if (pairingStatus) pairingStatus.textContent = 'Generating listings with ChatGPT...';
        
        try {
          const exec = window.authClient?.authFetch ?? fetch;
          const res = await exec('/.netlify/functions/smartdrafts-create-drafts', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ products: pairedProducts }),
          });
          
          const data = await res.json().catch(() => ({}));
          if (!res.ok || !data?.ok) {
            throw new Error(data?.error || `Draft creation failed (${res.status})`);
          }
          
          const drafts = data.drafts || [];
          if (pairingStatus) {
            pairingStatus.textContent = `✅ Generated ${drafts.length} listing(s)! Total: ${data.summary?.total || 0}, Succeeded: ${data.summary?.succeeded || 0}, Failed: ${data.summary?.failed || 0}`;
          }
          
          // Display generated drafts
          renderDrafts(drafts);
          
        } catch (err) {
          if (pairingStatus) {
            pairingStatus.textContent = `❌ Draft creation error: ${err?.message || err}`;
          }
        } finally {
          btnCreateDrafts.disabled = false;
          btnPairProducts.disabled = false;
        }
      });

      function renderPairedProducts(products) {
        if (!pairedProductsSection || !pairedProductsGrid) return;
        
        pairedProductsSection.style.display = products.length > 0 ? 'block' : 'none';
        pairedProductsGrid.innerHTML = '';
        
        products.forEach((product) => {
          const card = el('div', { class: 'card' });
          card.appendChild(el('div', { 
            html: `<strong>${product.brand || 'Unknown'} ${product.product || 'Product'}</strong>` 
          }));
          
          if (product.variant) {
            card.appendChild(el('div', { class: 'muted', text: product.variant }));
          }
          if (product.size) {
            card.appendChild(el('div', { class: 'muted', text: `Size: ${product.size}` }));
          }
          
          const thumbs = el('div', { class: 'thumbs' });
          if (product.heroDisplayUrl) {
            const thumb = el('div', { class: 'thumb' });
            thumb.appendChild(el('img', { src: product.heroDisplayUrl, alt: 'Front' }));
            thumb.appendChild(el('div', { class: 'thumb-badge', text: 'Front' }));
            thumbs.appendChild(thumb);
          }
          if (product.backDisplayUrl) {
            const thumb = el('div', { class: 'thumb' });
            thumb.appendChild(el('img', { src: product.backDisplayUrl, alt: 'Back' }));
            thumb.appendChild(el('div', { class: 'thumb-badge back', text: 'Back' }));
            thumbs.appendChild(thumb);
          }
          card.appendChild(thumbs);
          pairedProductsGrid.appendChild(card);
        });
      }

      function renderDrafts(drafts) {
        if (!draftsSection || !draftsGrid) return;
        
        draftsSection.style.display = drafts.length > 0 ? 'block' : 'none';
        draftsGrid.innerHTML = '';
        
        drafts.forEach((draft) => {
          const card = el('div', { class: 'card' });
          
          // Title
          card.appendChild(el('div', { html: `<strong>${draft.title}</strong>` }));
          
          // Meta
          const meta = [];
          if (draft.brand) meta.push(`Brand: ${draft.brand}`);
          if (draft.price) meta.push(`$${draft.price}`);
          if (draft.condition) meta.push(draft.condition);
          if (draft.category?.title) meta.push(draft.category.title);
          if (meta.length) {
            card.appendChild(el('div', { class: 'muted', text: meta.join(' • ') }));
          }
          
          // Description
          if (draft.description) {
            card.appendChild(el('div', { 
              style: 'margin-top:8px; font-size:14px; color:#444;',
              text: draft.description 
            }));
          }
          
          // Bullets
          if (draft.bullets && draft.bullets.length > 0) {
            const bulletList = el('ul', { class: 'bullet-list' });
            draft.bullets.forEach((bullet) => {
              bulletList.appendChild(el('li', { text: bullet }));
            });
            card.appendChild(bulletList);
          }
          
          // Aspects
          if (draft.aspects && Object.keys(draft.aspects).length > 0) {
            const aspectDetails = el('details', {});
            aspectDetails.appendChild(el('summary', { text: `Item Specifics (${Object.keys(draft.aspects).length})` }));
            const aspectList = el('div', { style: 'margin-top:4px; font-size:13px;' });
            Object.entries(draft.aspects).forEach(([key, values]) => {
              const valueStr = Array.isArray(values) ? values.join(', ') : values;
              aspectList.appendChild(el('div', { text: `${key}: ${valueStr}` }));
            });
            aspectDetails.appendChild(aspectList);
            card.appendChild(aspectDetails);
          }
          
          // Images
          if (draft.images && draft.images.length > 0) {
            const thumbs = el('div', { class: 'thumbs' });
            draft.images.slice(0, 6).forEach((url, idx) => {
              const thumb = el('div', { class: 'thumb' });
              thumb.appendChild(el('img', { src: url, alt: `Image ${idx + 1}` }));
              thumbs.appendChild(thumb);
            });
            card.appendChild(thumbs);
          }
          
          draftsGrid.appendChild(card);
        });
      }

  updateGenerateState();
  setWarnings([]);
  renderDebugData(null);
  setRawOutput(null);

      (async () => {
        const authed = await ensureAuth();
        if (!authed) {
          setStatus('Please sign in to load Dropbox folders.');
          return;
        }
        await loadFolders();
      })();
    </script>
  </body>
</html>
