<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Analyze — DNH Solutions</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    body{font-family:system-ui,Segoe UI,Arial,sans-serif;margin:24px;color:#111}
    .row{display:grid;grid-template-columns:1fr auto;gap:12px;margin-bottom:12px}
    textarea{width:100%;height:140px}
    button{padding:8px 14px;border:1px solid #ddd;border-radius:8px;cursor:pointer;background:#111;color:#fff}
    .muted{color:#666}
    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:16px;margin-top:16px}
    .card{border:1px solid #eee;border-radius:12px;padding:12px}
    .thumbs{display:flex;gap:6px;margin-top:8px;flex-wrap:wrap}
    .thumbs img{width:64px;height:64px;object-fit:cover;border:1px solid #eee;border-radius:8px}
    .bar{display:flex;align-items:center;gap:8px;margin-bottom:8px}
    .ok{color:#0a7}
    .bad{color:#a00}
    .debug-only{display:none}
    body.debug .debug-only{display:block}
  </style>
</head>
<body>
  <script src="/auth-client.js"></script>
  <h1>Analyze Images</h1>
  <div class="row">
    <textarea id="imgUrls" placeholder="Paste image URLs here (one per line)"></textarea>
    <div>
      <button id="runAnalyze">Analyze</button>
      <div style="margin-top:8px">
        <label class="muted" style="display:flex;align-items:center;gap:6px;user-select:none">
          <input type="checkbox" id="toggleDebug" /> Show debug
        </label>
      </div>
    </div>
  </div>
  <div id="status" class="muted"></div>
  <div id="groupsGrid" class="grid"></div>

  <div class="bar">
    <button id="btnCreateDrafts">Create Drafts</button>
    <span id="draftNote" class="muted">Select the groups you want to draft.</span>
  </div>

  <div id="debugWrap" style="display:none;margin-top:16px;border:1px solid #eee;border-radius:12px;padding:10px;background:#fafafa">
    <div style="display:flex;gap:8px;align-items:center;justify-content:space-between">
      <div class="muted">Debug</div>
      <div style="display:flex;gap:8px">
        <button id="copyDebug" type="button">Copy</button>
        <button id="clearDebug" type="button">Clear</button>
      </div>
    </div>
    <pre id="debugLog" style="white-space:pre-wrap;word-break:break-word;max-height:320px;overflow:auto;margin:8px 0 0"></pre>
  </div>

  <script type="module">
    const qs = (sel) => document.querySelector(sel);
    const qsa = (sel) => Array.from(document.querySelectorAll(sel));
    const el = (tag, attrs = {}, kids = []) => {
      const n = document.createElement(tag);
      for (const [k, v] of Object.entries(attrs)) k === 'html' ? (n.innerHTML = v) : n.setAttribute(k, v);
      kids.forEach((k) => n.appendChild(k));
      return n;
    };
    const uniq = (arr) => Array.from(new Set(arr));
    const parseUrls = (s) => uniq(s.split(/\r?\n/).map((x) => x.trim()).filter(Boolean));

    async function requireAuth() {
      try {
        const ok = await (window.authClient?.requireAuth?.() ?? Promise.resolve(false));
        return ok;
      } catch {
        return false;
      }
    }
    async function getToken() {
      try {
        return await (window.authClient?.getToken?.() ?? null);
      } catch {
        return null;
      }
    }

    // -------- Debug helpers --------
    const dbgState = { enabled: false, logs: [] };
    function dbgShow(show) {
      dbgState.enabled = !!show;
      const wrap = qs('#debugWrap');
      if (wrap) wrap.style.display = show ? 'block' : 'none';
      try { document.body.classList.toggle('debug', !!show); } catch {}
      if (!show) return;
      // Render current buffer
      const pre = qs('#debugLog');
      if (pre) pre.textContent = dbgState.logs.join('\n');
    }
    function dbg(label, payload) {
      try {
        const stamp = new Date().toISOString();
        const text = typeof payload === 'string' ? payload : JSON.stringify(payload, null, 2);
        const line = `[#${String(dbgState.logs.length + 1).padStart(3,'0')}] ${stamp} ${label}\n${text}`;
        dbgState.logs.push(line);
        if (dbgState.logs.length > 200) dbgState.logs.shift();
        if (dbgState.enabled) {
          const pre = qs('#debugLog');
          if (pre) pre.textContent = dbgState.logs.join('\n');
        }
      } catch {}
    }
    // Auto-enable via ?debug=1
    try { if (new URLSearchParams(location.search).get('debug') === '1') { const t = qs('#toggleDebug'); if (t) t.checked = true; dbgShow(true);} } catch {}
    const toggle = qs('#toggleDebug');
    if (toggle) toggle.addEventListener('change', (e) => dbgShow(!!e.target.checked));
    const copyBtn = qs('#copyDebug');
    if (copyBtn) copyBtn.addEventListener('click', async () => { try { await navigator.clipboard.writeText((qs('#debugLog')?.textContent)||''); } catch {} });
    const clearBtn = qs('#clearDebug');
    if (clearBtn) clearBtn.addEventListener('click', () => { dbgState.logs = []; const pre = qs('#debugLog'); if (pre) pre.textContent=''; });

    async function analyzeUrls(urls) {
      const t = await getToken();
      if (!t) throw new Error('Not authenticated');
      const hdr = { 'Content-Type': 'application/json', Authorization: `Bearer ${t}` };
      // Log input and normalized shapes (without secrets)
      try { dbg('analyze.input', { urls, authMode: await (window.authClient?.getMode?.()||Promise.resolve('unknown')), tokenPresent: !!t }); } catch { dbg('analyze.input', { urls }); }
      if (urls.length <= 3) {
        const endpoint = '/.netlify/functions/analyze-images-user';
        const body = JSON.stringify({ images: urls, batchSize: 12 });
        let r = await fetch(endpoint, {
          method: 'POST',
          headers: hdr,
          body,
        });
        if (r.status === 401) {
          dbg('auth.retry', { reason: '401 on analyze-images-user' });
          const ok = await requireAuth();
          if (ok) {
            const t2 = await getToken();
            const hdr2 = { 'Content-Type': 'application/json', Authorization: `Bearer ${t2}` };
            r = await fetch(endpoint, { method: 'POST', headers: hdr2, body });
          }
        }
  let data = {};
        try { data = await r.json(); } catch { data = { parse: 'failed', text: await r.text().catch(()=> '') }; }
        dbg('analyze.fg.response', { endpoint, status: r.status, ok: r.ok, body: data });
        if (r.status === 401) {
          // Try to fetch auth diagnostics to aid debugging
          try {
            const diag = await fetch('/.netlify/functions/auth-debug-user', { headers: { Authorization: hdr.Authorization } }).then(r => r.json()).catch(() => null);
            dbg('auth.debug', diag || { error: 'auth-debug failed' });
          } catch {}
          // Bubble a clear message to UI
          throw new Error('Sign-in required or token invalid. Please sign in and retry.');
        }
        if (data.status === 'redirect') return { mode: 'redirect' };
        return { mode: 'fg', data };
      }
      const endpoint = '/.netlify/functions/analyze-images-bg-user';
      const body = JSON.stringify({ images: urls, batchSize: 12 });
      let r = await fetch(endpoint, {
        method: 'POST',
        headers: hdr,
        body,
      });
      if (r.status === 401) {
        dbg('auth.retry', { reason: '401 on analyze-images-bg-user' });
        const ok = await requireAuth();
        if (ok) {
          const t2 = await getToken();
          const hdr2 = { 'Content-Type': 'application/json', Authorization: `Bearer ${t2}` };
          r = await fetch(endpoint, { method: 'POST', headers: hdr2, body });
        }
      }
  let jobResp = {};
      try { jobResp = await r.json(); } catch { jobResp = { parse: 'failed', text: await r.text().catch(()=> '') }; }
      dbg('analyze.bg.enqueue', { endpoint, status: r.status, ok: r.ok, body: jobResp });
      if (r.status === 401) {
        try {
          const diag = await fetch('/.netlify/functions/auth-debug-user', { headers: { Authorization: hdr.Authorization } }).then(r => r.json()).catch(() => null);
          dbg('auth.debug', diag || { error: 'auth-debug failed' });
        } catch {}
        throw new Error('Sign-in required or token invalid. Please sign in and retry.');
      }
      const { jobId } = jobResp;
      return { mode: 'bg', jobId };
    }

    async function pollJob(jobId) {
      const t = await getToken();
      if (!t) throw new Error('Not authenticated');
      const hdr = { Authorization: `Bearer ${t}` };
      for (let i = 0; i < 40; i++) {
        await new Promise((r) => setTimeout(r, 2000));
        const endpoint = `/.netlify/functions/analyze-images-status-user?jobId=${encodeURIComponent(jobId)}`;
        const r = await fetch(endpoint, { headers: hdr });
        let st = {};
        try { st = await r.json(); } catch { st = { parse: 'failed', text: await r.text().catch(()=> '') }; }
        dbg('analyze.bg.poll', { endpoint, status: r.status, ok: r.ok, body: st });
        if (st.state === 'complete' || st.state === 'error') return st;
      }
      throw new Error('Timed out waiting for job.');
    }

    async function getDefaultLocationKey() {
      try {
        const t = await getToken();
        if (!t) return '';
        const r = await fetch('/.netlify/functions/ebay-get-location-user', {
          headers: { Authorization: `Bearer ${t}` },
        });
        if (!r.ok) return '';
        const j = await r.json().catch(() => ({}));
        return (typeof j?.merchantLocationKey === 'string' ? j.merchantLocationKey : '') || '';
      } catch { return ''; }
    }

    async function renderGroups(result) {
      dbg('analyze.render.result', { summary: result?.summary, warnings: result?.warnings, groupsCount: (result?.groups || result?.data?.groups || []).length });
      const grid = qs('#groupsGrid');
      grid.innerHTML = '';
        const groups = result.groups || result.data?.groups || [];
        const warnings = result.warnings || result.data?.warnings || [];
      if (!groups.length) {
          const warnHtml = Array.isArray(warnings) && warnings.length
            ? `<div style="margin-top:8px;" class="muted">Warnings:<br>${warnings.map(w => `<div>• ${String(w).replace(/[<>]/g,'')}</div>`).join('')}</div>`
            : '';
          grid.innerHTML = `<div class="muted">No groups found.${warnHtml}</div>`;
        return;
      }
      window._currentJobId = result.jobId || 'adhoc';
      window._currentGroups = groups;

      // Pull the user's default merchantLocationKey once per render
      if (!window._defaultMerchantLocationKeyLoaded) {
        window._defaultMerchantLocationKey = await getDefaultLocationKey();
        window._defaultMerchantLocationKeyLoaded = true;
      }

      for (const g of groups) {
        try { dbg('group.images', { groupId: g.groupId, images: Array.isArray(g.images) ? g.images : [] }); } catch {}
        const title = [g.brand, g.product].filter(Boolean).join(' — ') || 'Unknown';
        const meta = [g.variant && `Variant: <code>${g.variant}</code>`, g.size && `Size: <code>${g.size}</code>`]
          .filter(Boolean)
          .join(' • ');
        const thumbs = el('div', { class: 'thumbs' });
        (g.images || []).slice(0, 6).forEach((u) => thumbs.appendChild(el('img', { src: u, alt: 'preview' })));
        const urlsBlock = el('div', { class: 'debug-only' }, [
          el('details', { open: true }, [
            el('summary', { html: 'Image URLs' }),
            el('pre', { html: (Array.isArray(g.images) ? g.images : []).map((u) => String(u)).join('\n') })
          ])
        ]);

        const pick = el('label', { html: `<input type="checkbox" data-pick value="${g.groupId}" checked> Use for draft` });

        const card = el('div', { class: 'card' }, [
          el('div', { html: `<strong>${title}</strong>` }),
          el('div', { class: 'muted', html: meta }),
          el('div', { class: 'muted', html: `Confidence: ${g.confidence ?? '—'}` }),
          thumbs,
          urlsBlock,
          pick,
          el('div', { class: 'muted', html: `<span data-cat="${g.groupId}"></span><div data-missing="${g.groupId}"></div><div data-ovrbox="${g.groupId}"></div>` }),
        ]);

        // Build overrides UI (Phase 2B)
        (function buildOverridesUI() {
          const jobId = window._currentJobId || 'adhoc';
          const missing = g._meta?.missingRequired || [];
          const catSpan = card.querySelector(`[data-cat="${g.groupId}"]`);
          const missDiv = card.querySelector(`[data-missing="${g.groupId}"]`);
          const ovrBox = card.querySelector(`[data-ovrbox="${g.groupId}"]`);

          catSpan.innerHTML = g._meta?.selectedCategory
            ? `Category: <code>${g._meta.selectedCategory.title}</code> (<code>${g._meta.selectedCategory.id}</code>)`
            : `Category: <i>auto</i>`;

          const list = el('div');
          if (Array.isArray(missing) && missing.length) {
            missDiv.innerHTML = `Missing required: ${missing.map((x) => `<code>${x}</code>`).join(' ')}`;
            missing.forEach((name) => {
              const row = el('div', { html: `<label>${name}: <input data-aspect="${name}" placeholder="enter ${name}"></label>` });
              list.appendChild(row);
            });
          } else {
            missDiv.innerHTML = '';
          }

          // Offer overrides (Price & Merchant Location Key)
          const offerBox = el('div', { class: 'muted' });
          offerBox.appendChild(el('div', { html: `<label>Price (USD): <input type="number" step="0.01" min="0" data-offer-price placeholder="auto"></label>` }));
          const defaultMlk = (window._defaultMerchantLocationKey || '').trim();
          const mlkPlaceholder = defaultMlk ? `default: ${defaultMlk}` : 'env or enter per-user key';
          offerBox.appendChild(el('div', { html: `<label>Merchant Location Key: <input data-offer-mlk placeholder="${mlkPlaceholder}"></label>` }));
          offerBox.appendChild(el('div', { html: `<label><input type="checkbox" data-offer-mlk-default> Save as my default</label>` }));

          const saveBtn = el('button', { html: 'Save Overrides' });
          saveBtn.addEventListener('click', async () => {
            const inputs = Array.from(list.querySelectorAll('input[data-aspect]'));
            const aspects = {};
            inputs.forEach((inp) => {
              const v = inp.value.trim();
              if (v) aspects[inp.getAttribute('data-aspect')] = v;
            });
            const pEl = card.querySelector('input[data-offer-price]');
            const mlkEl = card.querySelector('input[data-offer-mlk]');
            const price = pEl && pEl.value ? Number(pEl.value) : undefined;
            const merchantLocationKey = mlkEl && mlkEl.value ? mlkEl.value.trim() : undefined;
            const offer = {};
            if (typeof price === 'number' && Number.isFinite(price) && price > 0) offer.price = price;
            if (merchantLocationKey) offer.merchantLocationKey = merchantLocationKey;
            try {
              await saveOverrides(jobId, g.groupId, aspects, null, offer);
              const makeDefault = card.querySelector('input[data-offer-mlk-default]');
              const makeDefaultChecked = !!(makeDefault && makeDefault instanceof HTMLInputElement && makeDefault.checked);
              if (makeDefaultChecked && offer.merchantLocationKey) {
                await saveDefaultLocation(offer.merchantLocationKey);
              }
              missDiv.innerHTML = '<span class="ok">Saved. Re-Create Drafts to apply.</span>';
            } catch (e) {
              missDiv.innerHTML = `<span class="bad">Save failed: ${e?.message || e}</span>`;
            }
          });
          ovrBox.appendChild(list);
          ovrBox.appendChild(offerBox);
          ovrBox.appendChild(saveBtn);

          // If we have a default and no group-level override present in data, prefill the input value
          try {
            const mlkInp = card.querySelector('input[data-offer-mlk]');
            const groupOverride = g?.offer?.merchantLocationKey || g?._meta?.offer?.merchantLocationKey || null;
            if (mlkInp && !groupOverride && defaultMlk) {
              mlkInp.value = defaultMlk;
            }
          } catch {}
        })();

        grid.appendChild(card);
      }
      window._currentAnalyzeResult = result;
    }

    async function saveOverrides(jobId, groupId, aspects, categoryId, offer) {
      const t = await getToken();
      if (!t) throw new Error('Not authenticated');
      const hdr = { 'Content-Type': 'application/json', Authorization: `Bearer ${t}` };
      const body = JSON.stringify({ jobId, groupId, aspects, categoryId, offer });
      const r = await fetch('/.netlify/functions/taxonomy-override-upsert', { method: 'POST', headers: hdr, body });
      if (!r.ok) throw new Error(`override save failed: ${await r.text()}`);
    }

    async function saveDefaultLocation(merchantLocationKey) {
      const t = await getToken();
      if (!t) throw new Error('Not authenticated');
      const hdr = { 'Content-Type': 'application/json', Authorization: `Bearer ${t}` };
      const body = JSON.stringify({ merchantLocationKey });
      const r = await fetch('/.netlify/functions/ebay-set-location-user', { method: 'POST', headers: hdr, body });
      if (!r.ok) throw new Error(`set default failed: ${await r.text()}`);
    }

    qs('#runAnalyze').addEventListener('click', async () => {
      const urls = parseUrls(qs('#imgUrls').value);
      const status = qs('#status');
      if (!urls.length) return (status.textContent = 'Paste image URLs first.');
      status.textContent = 'Analyzing…';
      try {
        await requireAuth();
        const start = await analyzeUrls(urls);
        if (start.mode === 'fg') {
          renderGroups(start);
          status.textContent = 'Done.';
        } else if (start.mode === 'redirect') {
          status.textContent = 'Redirected to background.';
        } else {
          status.textContent = `Queued job ${start.jobId}…`;
          const fin = await pollJob(start.jobId);
          renderGroups(fin);
          status.textContent = 'Complete.';
        }
      } catch (e) {
        status.textContent = 'Error: ' + (e?.message || e);
      }
    });

    qs('#btnCreateDrafts').addEventListener('click', createDraftsFromSelected);

    async function createDraftsFromSelected() {
      const status = qs('#status');
      const groups = window._currentGroups || [];
      const pickedIds = new Set(qsa('input[type=checkbox][data-pick]').filter((i) => i.checked).map((i) => i.value));
      const picked = groups.filter((g) => pickedIds.has(g.groupId));
      if (!picked.length) {
        status.textContent = 'No groups selected.';
        return;
      }
      try {
        const t = await getToken();
        if (!t) throw new Error('Not authenticated');
        const hdr = { 'Content-Type': 'application/json', Authorization: `Bearer ${t}` };
        const body = JSON.stringify({ jobId: window._currentJobId || 'adhoc', groups: picked });
        const endpoint = '/.netlify/functions/create-ebay-draft-user';
        const r = await fetch(endpoint, { method: 'POST', headers: hdr, body });
        let data = {};
        try { data = await r.json(); } catch { data = { parse: 'failed', text: await r.text().catch(()=> '') }; }
        dbg('draft.create.response', { endpoint, status: r.status, ok: r.ok, body: data });
        if (data.dryRun) {
          status.textContent = `DRY RUN: ${data.count} preview(s)`;
        } else if (data.ok && (data.created > 0 || (data.results || []).length > 0)) {
          const first = (data.results || [])[0];
          const s = String(first?.status || '').toUpperCase();
          const draftStatuses = new Set(['UNPUBLISHED', 'INACTIVE', 'DRAFT']);
          status.textContent = draftStatuses.has(s)
            ? `Draft created: Offer ${first.offerId} (status: ${s})`
            : `Offer status: ${s || 'unknown'}`;
        } else {
          status.textContent = `Create draft failed: ${JSON.stringify(data)}`;
        }
      } catch (e) {
        status.textContent = 'Error: ' + (e?.message || e);
      }
    }
  </script>
</body>
</html>
