import express from 'express';
import { z } from 'zod';
import { groupProductsFromDropbox } from '../utils/grouping.js';
import { computeEbayPrice, computeFloorPrice } from '../utils/pricing.js';
import {
  ensureInventoryItem,
  createOffer,
  publishOffer,
  ensureEbayPrereqs,
} from '../services/ebay.js';
import { cfg } from '../config.js';
import { getRawLink, listFolder } from '../services/dropbox.js';
import fs from 'fs';
import path from 'path';

export const processRouter = express.Router();

const BodySchema = z.object({
  mode: z.enum(['draft', 'post', 'legacy-post']).optional(),
  folderPath: z.string().default('/EBAY'),
  limit: z.number().int().positive().max(100).optional(),
  quantityDefault: z.number().int().positive().default(1),
  marketplaceId: z.string().default('EBAY_US'),
  categoryId: z.string().optional(),
});

processRouter.post('/process', async (req, res) => {
  try {
    const body = BodySchema.parse({
      ...req.body,
      limit: req.query.limit ? Number(req.query.limit) : undefined,
    });
    const entries = await listFolder('demo', body.folderPath);

    const grouped = groupProductsFromDropbox(entries.entries);
    const groups = grouped.slice(0, body.limit || grouped.length || 10);

    // Ensure eBay seller prerequisites (policies, location) exist at runtime.
    // If env/config doesn't contain policy IDs, create them now and update cfg in-memory.
    if (
      !cfg.ebay.policy.paymentPolicyId ||
      !cfg.ebay.policy.returnPolicyId ||
      !cfg.ebay.policy.fulfillmentPolicyId ||
      !cfg.ebay.merchantLocationKey
    ) {
      const ids = await ensureEbayPrereqs('demo');
      cfg.ebay.policy.paymentPolicyId = ids.paymentPolicyId;
      cfg.ebay.policy.returnPolicyId = ids.returnPolicyId;
      cfg.ebay.policy.fulfillmentPolicyId = ids.fulfillmentPolicyId;
      cfg.ebay.merchantLocationKey = ids.merchantLocationKey;
      console.error('Auto-provisioned eBay policies and merchant location:', ids);
    }

    const results: any[] = [];
    for (const g of groups) {
      // choose main image path: prefer g.main, fall back to first gallery image; skip if none
      const mainPath = g.main?.path_lower ?? g.gallery[0]?.path_lower;
      if (!mainPath) {
        // no images available for this group, skip and record an entry
        results.push({ sku: g.sku, error: 'no images found', mode: body.mode || 'draft' });
        continue;
      }

      const mainUrl = await getRawLink('demo', mainPath);
      const galleryUrls: string[] = [];
      for (const f of g.gallery) {
        if (f && f.path_lower && f.path_lower !== mainPath) {
          galleryUrls.push(await getRawLink('demo', f.path_lower));
        }
      }

      // price: still a stub (parse from filename); wire real OCR later
      const basePrice = Number((g.priceImageName.match(/[0-9]+(\\.[0-9]{1,2})?/) || ['0'])[0]);
      const ebayPrice = computeEbayPrice(basePrice);
      const floor = computeFloorPrice(ebayPrice);

      try {
        await ensureInventoryItem('demo', g.sku, {
          title: `Sample Listing ${g.sku}`,
          description: `Autogenerated from Dropbox group ${g.sku}.`,
          condition: 'NEW',
          quantity: req.body.quantityDefault || 1,
          imageUrls: [mainUrl, ...galleryUrls],
        });

        // allow per-SKU category override via data file: .tmp/category_map.json
        let categoryId = body.categoryId || cfg.ebay.defaultCategoryId || '99'; // Everything Else
        try {
          const mapPath = path.join(cfg.dataDir, 'category_map.json');
          if (fs.existsSync(mapPath)) {
            const mapJson = JSON.parse(fs.readFileSync(mapPath, 'utf8') || '{}');
            if (mapJson[g.sku]) categoryId = String(mapJson[g.sku]);
          }
        } catch (e) {
          /* ignore parse errors and fallback to defaults */
        }

        const offer = await createOffer('demo', g.sku, {
          marketplaceId: body.marketplaceId,
          categoryId,
          price: ebayPrice,
          quantity: req.body.quantityDefault || 1,
        });

        if ((body.mode || 'draft') === 'post') {
          await publishOffer('demo', offer.offerId);
        }
        results.push({
          sku: g.sku,
          offerId: offer.offerId,
          mode: body.mode || 'draft',
          price: ebayPrice,
          floor,
        });
      } catch (err: any) {
        // Capture the error message (may include eBay JSON) and continue.
        // If the error message is a stringified JSON from eBay, parse it so
        // the API response contains structured data instead of an escaped string.
        const msg = err?.message || String(err);
        let parsed: any = msg;
        try {
          parsed = JSON.parse(msg);
        } catch {
          // leave as raw string when not JSON
        }
        console.error('Process item error for', g.sku, parsed);
        results.push({ sku: g.sku, error: parsed, mode: body.mode || 'draft' });
      }
    }

    res.json({ ok: true, count: results.length, results });
  } catch (e: any) {
    // Top-level errors may also contain stringified JSON in e.message.
    let errBody: any = e?.message || String(e);
    try {
      errBody = JSON.parse(errBody);
    } catch {
      // keep original message
    }
    res.status(400).json({ error: errBody });
  }
});
