// Mock environment before imports
process.env.DEFAULT_MARKETPLACE_ID = 'EBAY_US';

import { putInventoryItem, createOffer } from '../../src/lib/ebay-sell.js';
import type { TaxonomyMappedDraft } from '../../src/lib/map-group-to-draft.js';

// Mock global fetch
global.fetch = jest.fn();

describe('ebay-sell', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('putInventoryItem', () => {
    const baseInventory: TaxonomyMappedDraft['inventory'] = {
      product: {
        title: 'Test Product',
        description: 'Test Description',
        imageUrls: ['https://example.com/image1.jpg', 'https://example.com/image2.jpg'],
        aspects: {
          Brand: ['TestBrand'],
          Color: ['Blue'],
        },
      },
    };

    describe('Basic functionality', () => {
      it('should create inventory item successfully', async () => {
        mockFetch.mockResolvedValueOnce({
          ok: true,
          status: 200,
          text: async () => '',
        } as any);

        await putInventoryItem(
          'test-token',
          'https://api.ebay.com',
          'SKU123',
          baseInventory,
          5
        );

        expect(mockFetch).toHaveBeenCalledTimes(1);
        const call = mockFetch.mock.calls[0];
        expect(call[0]).toBe('https://api.ebay.com/sell/inventory/v1/inventory_item/SKU123');
        expect(call[1]?.method).toBe('PUT');
      });

      it('should include authorization header', async () => {
        mockFetch.mockResolvedValueOnce({ ok: true, text: async () => '' } as any);

        await putInventoryItem(
          'test-token-123',
          'https://api.ebay.com',
          'SKU123',
          baseInventory,
          5
        );

        const headers = mockFetch.mock.calls[0][1]?.headers as Record<string, string>;
        expect(headers.Authorization).toBe('Bearer test-token-123');
      });

      it('should include marketplace ID header', async () => {
        mockFetch.mockResolvedValueOnce({ ok: true, text: async () => '' } as any);

        await putInventoryItem(
          'test-token',
          'https://api.ebay.com',
          'SKU123',
          baseInventory,
          5,
          'EBAY_UK'
        );

        const headers = mockFetch.mock.calls[0][1]?.headers as Record<string, string>;
        expect(headers['X-EBAY-C-MARKETPLACE-ID']).toBe('EBAY_UK');
      });

      it('should default to EBAY_US marketplace', async () => {
        mockFetch.mockResolvedValueOnce({ ok: true, text: async () => '' } as any);

        await putInventoryItem(
          'test-token',
          'https://api.ebay.com',
          'SKU123',
          baseInventory,
          5
        );

        const headers = mockFetch.mock.calls[0][1]?.headers as Record<string, string>;
        expect(headers['X-EBAY-C-MARKETPLACE-ID']).toBe('EBAY_US');
      });

      it('should include quantity in payload', async () => {
        mockFetch.mockResolvedValueOnce({ ok: true, text: async () => '' } as any);

        await putInventoryItem(
          'test-token',
          'https://api.ebay.com',
          'SKU123',
          baseInventory,
          10
        );

        const body = JSON.parse(mockFetch.mock.calls[0][1]?.body as string);
        expect(body.availability.shipToLocationAvailability.quantity).toBe(10);
      });

      it('should include product details', async () => {
        mockFetch.mockResolvedValueOnce({ ok: true, text: async () => '' } as any);

        await putInventoryItem(
          'test-token',
          'https://api.ebay.com',
          'SKU123',
          baseInventory,
          5
        );

        const body = JSON.parse(mockFetch.mock.calls[0][1]?.body as string);
        expect(body.product.title).toBe('Test Product');
        expect(body.product.description).toBe('Test Description');
      });

      it('should include aspects', async () => {
        mockFetch.mockResolvedValueOnce({ ok: true, text: async () => '' } as any);

        await putInventoryItem(
          'test-token',
          'https://api.ebay.com',
          'SKU123',
          baseInventory,
          5
        );

        const body = JSON.parse(mockFetch.mock.calls[0][1]?.body as string);
        expect(body.product.aspects.Brand).toEqual(['TestBrand']);
        expect(body.product.aspects.Color).toEqual(['Blue']);
      });

      it('should include package dimensions', async () => {
        mockFetch.mockResolvedValueOnce({ ok: true, text: async () => '' } as any);

        await putInventoryItem(
          'test-token',
          'https://api.ebay.com',
          'SKU123',
          baseInventory,
          5
        );

        const body = JSON.parse(mockFetch.mock.calls[0][1]?.body as string);
        expect(body.packageWeightAndSize).toBeDefined();
        expect(body.packageWeightAndSize.dimensions.unit).toBe('INCH');
        expect(body.packageWeightAndSize.weight.unit).toBe('POUND');
      });

      it('should include condition when provided', async () => {
        mockFetch.mockResolvedValueOnce({ ok: true, text: async () => '' } as any);

        const inventoryWithCondition = {
          ...baseInventory,
          condition: 1000,
        };

        await putInventoryItem(
          'test-token',
          'https://api.ebay.com',
          'SKU123',
          inventoryWithCondition,
          5
        );

        const body = JSON.parse(mockFetch.mock.calls[0][1]?.body as string);
        expect(body.condition).toBe(1000);
      });
    });

    describe('Image URL sanitization', () => {
      it('should accept valid https URLs', async () => {
        mockFetch.mockResolvedValueOnce({ ok: true, text: async () => '' } as any);

        await putInventoryItem(
          'test-token',
          'https://api.ebay.com',
          'SKU123',
          baseInventory,
          5
        );

        const body = JSON.parse(mockFetch.mock.calls[0][1]?.body as string);
        expect(body.product.imageUrls).toContain('https://example.com/image1.jpg');
      });

      it('should accept valid http URLs', async () => {
        mockFetch.mockResolvedValueOnce({ ok: true, text: async () => '' } as any);

        const inventory = {
          product: {
            title: 'Test',
            imageUrls: ['http://example.com/image.jpg'],
            aspects: {},
          },
        };

        await putInventoryItem(
          'test-token',
          'https://api.ebay.com',
          'SKU123',
          inventory,
          5
        );

        const body = JSON.parse(mockFetch.mock.calls[0][1]?.body as string);
        expect(body.product.imageUrls).toContain('http://example.com/image.jpg');
      });

      it('should filter out invalid URLs', async () => {
        mockFetch.mockResolvedValueOnce({ ok: true, text: async () => '' } as any);

        const inventory = {
          product: {
            title: 'Test',
            imageUrls: [
              'https://example.com/valid.jpg',
              'invalid-url',
              '',
              'https://example.com/valid2.jpg',
            ],
            aspects: {},
          },
        };

        await putInventoryItem(
          'test-token',
          'https://api.ebay.com',
          'SKU123',
          inventory,
          5
        );

        const body = JSON.parse(mockFetch.mock.calls[0][1]?.body as string);
        expect(body.product.imageUrls).toEqual([
          'https://example.com/valid.jpg',
          'https://example.com/valid2.jpg',
        ]);
      });

      it('should limit to 12 images', async () => {
        mockFetch.mockResolvedValueOnce({ ok: true, text: async () => '' } as any);

        const imageUrls = Array.from({ length: 20 }, (_, i) => `https://example.com/img${i}.jpg`);
        const inventory = {
          product: {
            title: 'Test',
            imageUrls,
            aspects: {},
          },
        };

        await putInventoryItem(
          'test-token',
          'https://api.ebay.com',
          'SKU123',
          inventory,
          5
        );

        const body = JSON.parse(mockFetch.mock.calls[0][1]?.body as string);
        expect(body.product.imageUrls).toHaveLength(12);
      });

      it('should throw error if no valid images', async () => {
        const inventory = {
          product: {
            title: 'Test',
            imageUrls: ['invalid', ''],
            aspects: {},
          },
        };

        await expect(
          putInventoryItem('test-token', 'https://api.ebay.com', 'SKU123', inventory, 5)
        ).rejects.toThrow('No valid image URLs found');
      });

      it('should throw error if empty image array', async () => {
        const inventory = {
          product: {
            title: 'Test',
            imageUrls: [],
            aspects: {},
          },
        };

        await expect(
          putInventoryItem('test-token', 'https://api.ebay.com', 'SKU123', inventory, 5)
        ).rejects.toThrow('No valid image URLs found');
      });
    });

    describe('Quantity sanitization', () => {
      it('should use provided quantity', async () => {
        mockFetch.mockResolvedValueOnce({ ok: true, text: async () => '' } as any);

        await putInventoryItem(
          'test-token',
          'https://api.ebay.com',
          'SKU123',
          baseInventory,
          7
        );

        const body = JSON.parse(mockFetch.mock.calls[0][1]?.body as string);
        expect(body.availability.shipToLocationAvailability.quantity).toBe(7);
      });

      it('should truncate fractional quantities', async () => {
        mockFetch.mockResolvedValueOnce({ ok: true, text: async () => '' } as any);

        await putInventoryItem(
          'test-token',
          'https://api.ebay.com',
          'SKU123',
          baseInventory,
          5.7
        );

        const body = JSON.parse(mockFetch.mock.calls[0][1]?.body as string);
        expect(body.availability.shipToLocationAvailability.quantity).toBe(5);
      });

      it('should default to 1 for zero quantity', async () => {
        mockFetch.mockResolvedValueOnce({ ok: true, text: async () => '' } as any);

        await putInventoryItem(
          'test-token',
          'https://api.ebay.com',
          'SKU123',
          baseInventory,
          0
        );

        const body = JSON.parse(mockFetch.mock.calls[0][1]?.body as string);
        expect(body.availability.shipToLocationAvailability.quantity).toBe(1);
      });

      it('should default to 1 for negative quantity', async () => {
        mockFetch.mockResolvedValueOnce({ ok: true, text: async () => '' } as any);

        await putInventoryItem(
          'test-token',
          'https://api.ebay.com',
          'SKU123',
          baseInventory,
          -5
        );

        const body = JSON.parse(mockFetch.mock.calls[0][1]?.body as string);
        expect(body.availability.shipToLocationAvailability.quantity).toBe(1);
      });
    });

    describe('Aspects sanitization', () => {
      it('should limit aspect values to 25', async () => {
        mockFetch.mockResolvedValueOnce({ ok: true, text: async () => '' } as any);

        const manyValues = Array.from({ length: 30 }, (_, i) => `Value${i}`);
        const inventory = {
          product: {
            title: 'Test',
            imageUrls: ['https://example.com/img.jpg'],
            aspects: {
              TestAspect: manyValues,
            },
          },
        };

        await putInventoryItem(
          'test-token',
          'https://api.ebay.com',
          'SKU123',
          inventory,
          5
        );

        const body = JSON.parse(mockFetch.mock.calls[0][1]?.body as string);
        expect(body.product.aspects.TestAspect).toHaveLength(25);
      });

      it('should filter empty aspect values', async () => {
        mockFetch.mockResolvedValueOnce({ ok: true, text: async () => '' } as any);

        const inventory = {
          product: {
            title: 'Test',
            imageUrls: ['https://example.com/img.jpg'],
            aspects: {
              Brand: ['TestBrand', '', '  ', 'AnotherBrand'],
            },
          },
        };

        await putInventoryItem(
          'test-token',
          'https://api.ebay.com',
          'SKU123',
          inventory,
          5
        );

        const body = JSON.parse(mockFetch.mock.calls[0][1]?.body as string);
        expect(body.product.aspects.Brand).toEqual(['TestBrand', 'AnotherBrand']);
      });

      it('should omit aspects with no valid values', async () => {
        mockFetch.mockResolvedValueOnce({ ok: true, text: async () => '' } as any);

        const inventory = {
          product: {
            title: 'Test',
            imageUrls: ['https://example.com/img.jpg'],
            aspects: {
              Brand: ['TestBrand'],
              EmptyAspect: ['', '  '],
            },
          },
        };

        await putInventoryItem(
          'test-token',
          'https://api.ebay.com',
          'SKU123',
          inventory,
          5
        );

        const body = JSON.parse(mockFetch.mock.calls[0][1]?.body as string);
        expect(body.product.aspects.Brand).toEqual(['TestBrand']);
        expect(body.product.aspects.EmptyAspect).toBeUndefined();
      });
    });

    describe('Error handling', () => {
      it('should throw on non-200 response', async () => {
        mockFetch.mockResolvedValueOnce({
          ok: false,
          status: 400,
          text: async () => 'Bad Request',
        } as any);

        await expect(
          putInventoryItem('test-token', 'https://api.ebay.com', 'SKU123', baseInventory, 5)
        ).rejects.toThrow('Inventory PUT failed 400');
      });

      it('should throw on network error', async () => {
        mockFetch.mockRejectedValueOnce(new Error('Network error'));

        await expect(
          putInventoryItem('test-token', 'https://api.ebay.com', 'SKU123', baseInventory, 5)
        ).rejects.toThrow('Network error');
      });

      it('should handle error response detail', async () => {
        mockFetch.mockResolvedValueOnce({
          ok: false,
          status: 422,
          text: async () => '{"error":"Invalid SKU"}',
        } as any);

        await expect(
          putInventoryItem('test-token', 'https://api.ebay.com', 'SKU123', baseInventory, 5)
        ).rejects.toThrow('{"error":"Invalid SKU"}');
      });
    });
  });

  describe('createOffer', () => {
    const basePayload = {
      sku: 'SKU123',
      marketplaceId: 'EBAY_US',
      categoryId: '12345',
      price: 29.99,
      quantity: 5,
      condition: 1000,
      fulfillmentPolicyId: 'FP123',
      paymentPolicyId: 'PAY123',
      returnPolicyId: 'RET123',
      merchantLocationKey: 'warehouse-1',
      description: 'Test product description',
    };

    describe('Basic functionality', () => {
      it('should create offer successfully', async () => {
        mockFetch
          .mockResolvedValueOnce({
            ok: true,
            status: 200,
            text: async () => '',
          } as any) // location check
          .mockResolvedValueOnce({
            ok: true,
            status: 201,
            text: async () => JSON.stringify({ offerId: 'OFFER123' }),
          } as any);

        const result = await createOffer(
          'test-token',
          'https://api.ebay.com',
          basePayload
        );

        expect(result.offerId).toBe('OFFER123');
      });

      it('should check inventory location first', async () => {
        mockFetch
          .mockResolvedValueOnce({ ok: true, text: async () => '' } as any)
          .mockResolvedValueOnce({
            ok: true,
            text: async () => JSON.stringify({ offerId: 'OFFER123' }),
          } as any);

        await createOffer('test-token', 'https://api.ebay.com', basePayload);

        expect(mockFetch).toHaveBeenCalledTimes(2);
        const locationCall = mockFetch.mock.calls[0][0] as string;
        expect(locationCall).toContain('/sell/inventory/v1/location/warehouse-1');
      });

      it('should cache location check', async () => {
        mockFetch
          .mockResolvedValueOnce({ ok: true, text: async () => '' } as any)
          .mockResolvedValueOnce({
            ok: true,
            text: async () => JSON.stringify({ offerId: 'OFFER1' }),
          } as any)
          .mockResolvedValueOnce({
            ok: true,
            text: async () => JSON.stringify({ offerId: 'OFFER2' }),
          } as any);

        await createOffer('test-token', 'https://api.ebay.com', basePayload);
        await createOffer('test-token', 'https://api.ebay.com', basePayload);

        // Should only check location once (first call)
        expect(mockFetch).toHaveBeenCalledTimes(3); // 1 location + 2 offers
      });

      it('should include price in USD', async () => {
        mockFetch
          .mockResolvedValueOnce({ ok: true, text: async () => '' } as any)
          .mockResolvedValueOnce({
            ok: true,
            text: async () => JSON.stringify({ offerId: 'OFFER123' }),
          } as any);

        await createOffer('test-token', 'https://api.ebay.com', basePayload);

        const offerBody = JSON.parse(mockFetch.mock.calls[1][1]?.body as string);
        expect(offerBody.pricingSummary.price.currency).toBe('USD');
        expect(offerBody.pricingSummary.price.value).toBe('29.99');
      });

      it('should include policy IDs', async () => {
        mockFetch
          .mockResolvedValueOnce({ ok: true, text: async () => '' } as any)
          .mockResolvedValueOnce({
            ok: true,
            text: async () => JSON.stringify({ offerId: 'OFFER123' }),
          } as any);

        await createOffer('test-token', 'https://api.ebay.com', basePayload);

        const offerBody = JSON.parse(mockFetch.mock.calls[1][1]?.body as string);
        expect(offerBody.listingPolicies.fulfillmentPolicyId).toBe('FP123');
        expect(offerBody.listingPolicies.paymentPolicyId).toBe('PAY123');
        expect(offerBody.listingPolicies.returnPolicyId).toBe('RET123');
      });

      it('should include condition', async () => {
        mockFetch
          .mockResolvedValueOnce({ ok: true, text: async () => '' } as any)
          .mockResolvedValueOnce({
            ok: true,
            text: async () => JSON.stringify({ offerId: 'OFFER123' }),
          } as any);

        await createOffer('test-token', 'https://api.ebay.com', basePayload);

        const offerBody = JSON.parse(mockFetch.mock.calls[1][1]?.body as string);
        expect(offerBody.condition).toBe(1000);
      });

      it('should default to NEW condition if not provided', async () => {
        mockFetch
          .mockResolvedValueOnce({ ok: true, text: async () => '' } as any)
          .mockResolvedValueOnce({
            ok: true,
            text: async () => JSON.stringify({ offerId: 'OFFER123' }),
          } as any);

        const payloadWithoutCondition = { ...basePayload };
        delete (payloadWithoutCondition as any).condition;

        await createOffer('test-token', 'https://api.ebay.com', payloadWithoutCondition);

        const offerBody = JSON.parse(mockFetch.mock.calls[1][1]?.body as string);
        expect(offerBody.condition).toBe(1000);
      });

      it('should include merchant data if provided', async () => {
        mockFetch
          .mockResolvedValueOnce({ ok: true, text: async () => '' } as any)
          .mockResolvedValueOnce({
            ok: true,
            text: async () => JSON.stringify({ offerId: 'OFFER123' }),
          } as any);

        const payloadWithMetadata = {
          ...basePayload,
          merchantData: { pricingStatus: 'auto', jobId: 'job123' },
        };

        await createOffer('test-token', 'https://api.ebay.com', payloadWithMetadata);

        const offerBody = JSON.parse(mockFetch.mock.calls[1][1]?.body as string);
        expect(offerBody.merchantData).toEqual({
          pricingStatus: 'auto',
          jobId: 'job123',
        });
      });

      it('should return warnings if present', async () => {
        mockFetch
          .mockResolvedValueOnce({ ok: true, text: async () => '' } as any)
          .mockResolvedValueOnce({
            ok: true,
            text: async () =>
              JSON.stringify({
                offerId: 'OFFER123',
                warnings: [{ message: 'Image quality low' }],
              }),
          } as any);

        const result = await createOffer(
          'test-token',
          'https://api.ebay.com',
          basePayload
        );

        expect(result.warnings).toEqual([{ message: 'Image quality low' }]);
      });
    });

    describe('Price sanitization', () => {
      it('should round price to 2 decimals', async () => {
        mockFetch
          .mockResolvedValueOnce({ ok: true, text: async () => '' } as any)
          .mockResolvedValueOnce({
            ok: true,
            text: async () => JSON.stringify({ offerId: 'OFFER123' }),
          } as any);

        await createOffer('test-token', 'https://api.ebay.com', {
          ...basePayload,
          price: 29.999,
        });

        const offerBody = JSON.parse(mockFetch.mock.calls[1][1]?.body as string);
        expect(offerBody.pricingSummary.price.value).toBe('30.00');
      });

      it('should throw for zero price', async () => {
        mockFetch.mockResolvedValueOnce({ ok: true, text: async () => '' } as any);

        await expect(
          createOffer('test-token', 'https://api.ebay.com', {
            ...basePayload,
            price: 0,
          })
        ).rejects.toThrow('Invalid price');
      });

      it('should throw for negative price', async () => {
        mockFetch.mockResolvedValueOnce({ ok: true, text: async () => '' } as any);

        await expect(
          createOffer('test-token', 'https://api.ebay.com', {
            ...basePayload,
            price: -10,
          })
        ).rejects.toThrow('Invalid price');
      });
    });

    describe('Merchant location key', () => {
      it('should normalize location key with hyphens', async () => {
        mockFetch
          .mockResolvedValueOnce({ ok: true, text: async () => '' } as any)
          .mockResolvedValueOnce({
            ok: true,
            text: async () => JSON.stringify({ offerId: 'OFFER123' }),
          } as any);

        await createOffer('test-token', 'https://api.ebay.com', {
          ...basePayload,
          merchantLocationKey: 'warehouse 1',
        });

        const locationUrl = mockFetch.mock.calls[0][0] as string;
        expect(locationUrl).toContain('warehouse-1');
      });

      it('should throw for missing location key', async () => {
        await expect(
          createOffer('test-token', 'https://api.ebay.com', {
            ...basePayload,
            merchantLocationKey: null as any,
          })
        ).rejects.toThrow('Missing merchantLocationKey');
      });

      it('should throw for empty location key', async () => {
        await expect(
          createOffer('test-token', 'https://api.ebay.com', {
            ...basePayload,
            merchantLocationKey: '   ',
          })
        ).rejects.toThrow('Missing merchantLocationKey');
      });

      it('should throw if location not found', async () => {
        mockFetch.mockResolvedValueOnce({
          ok: false,
          status: 404,
          text: async () => 'Not found',
        } as any);

        await expect(
          createOffer('test-token', 'https://api.ebay.com', basePayload)
        ).rejects.toThrow("Inventory location 'warehouse-1' not found");
      });
    });

    describe('Policy validation', () => {
      it('should throw for missing fulfillment policy', async () => {
        await expect(
          createOffer('test-token', 'https://api.ebay.com', {
            ...basePayload,
            fulfillmentPolicyId: null as any,
          })
        ).rejects.toThrow('Missing eBay policy IDs');
      });

      it('should throw for missing payment policy', async () => {
        await expect(
          createOffer('test-token', 'https://api.ebay.com', {
            ...basePayload,
            paymentPolicyId: null as any,
          })
        ).rejects.toThrow('Missing eBay policy IDs');
      });

      it('should throw for missing return policy', async () => {
        await expect(
          createOffer('test-token', 'https://api.ebay.com', {
            ...basePayload,
            returnPolicyId: null as any,
          })
        ).rejects.toThrow('Missing eBay policy IDs');
      });
    });

    describe('Error handling', () => {
      it('should throw on offer creation failure', async () => {
        mockFetch
          .mockResolvedValueOnce({ ok: true, text: async () => '' } as any)
          .mockResolvedValueOnce({
            ok: false,
            status: 400,
            text: async () => '{"error":"Invalid category"}',
          } as any);

        await expect(
          createOffer('test-token', 'https://api.ebay.com', basePayload)
        ).rejects.toThrow('Offer create failed 400');
      });

      it('should throw if no offerId in response', async () => {
        mockFetch
          .mockResolvedValueOnce({ ok: true, text: async () => '' } as any)
          .mockResolvedValueOnce({
            ok: true,
            text: async () => JSON.stringify({ success: true }),
          } as any);

        await expect(
          createOffer('test-token', 'https://api.ebay.com', basePayload)
        ).rejects.toThrow('succeeded without offerId');
      });

      it('should handle malformed JSON response', async () => {
        mockFetch
          .mockResolvedValueOnce({ ok: true, text: async () => '' } as any)
          .mockResolvedValueOnce({
            ok: true,
            text: async () => 'invalid json{',
          } as any);

        await expect(
          createOffer('test-token', 'https://api.ebay.com', basePayload)
        ).rejects.toThrow('succeeded without offerId');
      });

      it('should handle nested offerId in response', async () => {
        mockFetch
          .mockResolvedValueOnce({ ok: true, text: async () => '' } as any)
          .mockResolvedValueOnce({
            ok: true,
            text: async () =>
              JSON.stringify({ offer: { offerId: 'NESTED123' } }),
          } as any);

        const result = await createOffer(
          'test-token',
          'https://api.ebay.com',
          basePayload
        );

        expect(result.offerId).toBe('NESTED123');
      });
    });
  });
});
