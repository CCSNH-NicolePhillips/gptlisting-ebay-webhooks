// Tests for taxonomy category selection

import { pickCategoryForGroup } from "../../src/lib/taxonomy-select.js";
import { listCategories, getCategoryById } from "../../src/lib/taxonomy-store.js";
import type { CategoryDef } from "../../src/lib/taxonomy-schema.js";

// Mock the taxonomy store
jest.mock("../../src/lib/taxonomy-store.js", () => ({
  listCategories: jest.fn(),
  getCategoryById: jest.fn(),
}));

const mockListCategories = listCategories as jest.MockedFunction<typeof listCategories>;
const mockGetCategoryById = getCategoryById as jest.MockedFunction<typeof getCategoryById>;

describe("Taxonomy Category Selection", () => {
  const mockCategories: CategoryDef[] = [
    {
      id: "177011",
      title: "Men's Shoes",
      slug: "Clothing, Shoes & Accessories > Men > Men's Shoes",
      marketplaceId: "EBAY_US",
      itemSpecifics: [],
      version: 1,
      updatedAt: Date.now(),
      scoreRules: {
        includes: ["men", "shoes", "sneakers", "boots"],
        excludes: ["women", "kids"],
        minScore: 2,
      },
    },
    {
      id: "3034",
      title: "Women's Bags",
      slug: "Clothing, Shoes & Accessories > Women > Women's Bags",
      marketplaceId: "EBAY_US",
      itemSpecifics: [],
      version: 1,
      updatedAt: Date.now(),
      scoreRules: {
        includes: ["women", "bag", "handbag", "purse"],
        excludes: ["men"],
        minScore: 2,
      },
    },
    {
      id: "267",
      title: "Books",
      slug: "Books & Magazines > Books",
      marketplaceId: "EBAY_US",
      itemSpecifics: [],
      version: 1,
      updatedAt: Date.now(),
      scoreRules: {
        includes: ["book", "novel", "textbook", "paperback"],
        excludes: ["magazine"],
        minScore: 1,
      },
    },
    {
      id: "268",
      title: "Biography",
      slug: "Books & Magazines > Books > Nonfiction > Biography",
      marketplaceId: "EBAY_US",
      itemSpecifics: [],
      version: 1,
      updatedAt: Date.now(),
      scoreRules: {
        includes: ["biography", "memoir", "autobiography"],
        excludes: [],
        minScore: 1,
      },
    },
  ];

  beforeEach(() => {
    jest.clearAllMocks();
    mockListCategories.mockResolvedValue(mockCategories);
    mockGetCategoryById.mockResolvedValue(null);
  });

  describe("pickCategoryForGroup", () => {
    test("returns null when no categories available", async () => {
      mockListCategories.mockResolvedValue([]);
      const result = await pickCategoryForGroup({
        brand: "Nike",
        product: "Running Shoes",
      });
      expect(result).toBeNull();
    });

    test("returns null when group has no relevant data", async () => {
      const result = await pickCategoryForGroup({});
      expect(result).toBeNull();
    });

    test("matches category by ID when category object provided", async () => {
      const categoryData: CategoryDef = {
        id: "177011",
        title: "Men's Shoes",
        slug: "Clothing, Shoes & Accessories > Men > Men's Shoes",
        marketplaceId: "EBAY_US",
        itemSpecifics: [],
        version: 1,
        updatedAt: Date.now(),
      };
      mockGetCategoryById.mockResolvedValue(categoryData);

      const result = await pickCategoryForGroup({
        category: { id: "177011" },
        brand: "Nike",
      });

      expect(mockGetCategoryById).toHaveBeenCalledWith("177011");
      expect(result).toEqual(categoryData);
    });

    test("matches category by exact title", async () => {
      const result = await pickCategoryForGroup({
        category: { title: "Men's Shoes" },
        brand: "Nike",
      });

      expect(result).not.toBeNull();
      expect(result!.id).toBe("177011");
      expect(result!.title).toBe("Men's Shoes");
    });

    test("matches category by slug", async () => {
      const result = await pickCategoryForGroup({
        category: { title: "Clothing, Shoes & Accessories > Men > Men's Shoes" },
      });

      expect(result).not.toBeNull();
      expect(result!.id).toBe("177011");
    });

    test("matches category path by last part", async () => {
      const result = await pickCategoryForGroup({
        category: { title: "Books > Nonfiction > Biography" },
      });

      expect(result).not.toBeNull();
      expect(result!.id).toBe("268");
      expect(result!.title).toBe("Biography");
    });

    test("matches category path by all parts", async () => {
      const result = await pickCategoryForGroup({
        category: { title: "Books > Biography" },
      });

      expect(result).not.toBeNull();
      // Should match Biography category which has "Books" in its slug
      expect(result!.id).toBe("268");
    });

    test("uses scoreRules matching when no category provided", async () => {
      const result = await pickCategoryForGroup({
        brand: "Nike",
        product: "Men's Running Shoes",
        variant: "Athletic Sneakers",
      });

      expect(result).not.toBeNull();
      expect(result!.id).toBe("177011"); // Men's Shoes has "men" and "shoes"
    });

    test("scoreRules matching requires minimum score", async () => {
      const result = await pickCategoryForGroup({
        product: "Something Random",
      });

      // No category should match with insufficient score
      expect(result).toBeNull();
    });

    test("scoreRules excludes work correctly", async () => {
      const result = await pickCategoryForGroup({
        brand: "Nike",
        product: "Women's Running Shoes", // Has "women" which excludes Men's Shoes
      });

      expect(result).not.toBeNull();
      // Should not match Men's Shoes (has "women" in excludes)
      // Should match Women's Bags (though "shoes" isn't in includes, this demonstrates exclude logic)
      expect(result!.id).not.toBe("177011");
    });

    test("picks category with highest score", async () => {
      const result = await pickCategoryForGroup({
        brand: "Random",
        product: "Women's Designer Handbag Purse",
        claims: ["luxury bag"],
      });

      expect(result).not.toBeNull();
      // Should match Women's Bags (has multiple matching keywords)
      expect(result!.id).toBe("3034");
    });

    test("handles claims array in scoring", async () => {
      const result = await pickCategoryForGroup({
        product: "Item",
        claims: ["biography", "book", "nonfiction"],
      });

      expect(result).not.toBeNull();
      expect(result!.id).toBe("268"); // Biography category
    });

    test("normalizes text to lowercase for matching", async () => {
      const result = await pickCategoryForGroup({
        brand: "NIKE",
        product: "MEN'S SHOES",
      });

      expect(result).not.toBeNull();
      expect(result!.id).toBe("177011");
    });

    test("handles category object with categoryId field", async () => {
      const categoryData: CategoryDef = {
        id: "267",
        title: "Books",
        slug: "Books & Magazines > Books",
        marketplaceId: "EBAY_US",
        itemSpecifics: [],
        version: 1,
        updatedAt: Date.now(),
      };
      mockGetCategoryById.mockResolvedValue(categoryData);

      const result = await pickCategoryForGroup({
        category: { categoryId: "267" },
      });

      expect(mockGetCategoryById).toHaveBeenCalledWith("267");
      expect(result).toEqual(categoryData);
    });

    test("falls back to scoreRules when category ID not found", async () => {
      mockGetCategoryById.mockResolvedValue(null);

      const result = await pickCategoryForGroup({
        category: { id: "999999", title: "Unknown" },
        product: "book novel",
      });

      // Should use scoreRules matching since ID lookup failed
      expect(result).not.toBeNull();
      expect(result!.id).toBe("267"); // Books category
    });

    test("enhances haystack with category keywords for path matching", async () => {
      const result = await pickCategoryForGroup({
        category: { title: "Books > Biography" },
        product: "Some Product",
      });

      expect(result).not.toBeNull();
      // Should match even though product doesn't have keywords, because category path is used
    });

    test("caches categories for performance", async () => {
      // First call
      await pickCategoryForGroup({ product: "test" });
      expect(mockListCategories).toHaveBeenCalledTimes(1);

      // Second call within cache TTL
      await pickCategoryForGroup({ product: "test2" });
      // Should not call listCategories again (cached)
      // Note: Cache is 30 seconds, so this works in tests
    });
  });
});
