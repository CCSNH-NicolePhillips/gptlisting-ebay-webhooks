// Tests for quota management
// Note: These tests mock node-fetch to avoid actual Upstash calls

import { canConsumeImages, consumeImages, canStartJob, incRunning, decRunning } from "../../src/lib/quota.js";

// Mock node-fetch
jest.mock("node-fetch", () => jest.fn());
import fetch from "node-fetch";
const mockFetch = fetch as jest.MockedFunction<typeof fetch>;

describe("Quota Management", () => {
  const originalEnv = process.env;

  beforeEach(() => {
    jest.clearAllMocks();
    process.env = {
      ...originalEnv,
      UPSTASH_REDIS_REST_URL: "https://test.upstash.io",
      UPSTASH_REDIS_REST_TOKEN: "test-token",
      USER_FREE_IMAGES_PER_DAY: "20",
      USER_MAX_RUNNING_JOBS: "2",
    };
  });

  afterAll(() => {
    process.env = originalEnv;
  });

  function mockUpstashResponse(result: any) {
    mockFetch.mockResolvedValue({
      ok: true,
      json: async () => ({ result }),
      text: async () => JSON.stringify({ result }),
      status: 200,
    } as any);
  }

  function mockUpstashError(status: number, message: string) {
    mockFetch.mockResolvedValue({
      ok: false,
      text: async () => message,
      status,
    } as any);
  }

  describe("canConsumeImages", () => {
    test("returns true when count is zero or negative", async () => {
      expect(await canConsumeImages("user123", 0)).toBe(true);
      expect(await canConsumeImages("user123", -5)).toBe(true);
      expect(mockFetch).not.toHaveBeenCalled();
    });

    test("returns true when under daily limit", async () => {
      mockUpstashResponse(10); // Current usage is 10
      const result = await canConsumeImages("user123", 5);
      expect(result).toBe(true); // 10 + 5 = 15 <= 20
    });

    test("returns false when would exceed daily limit", async () => {
      mockUpstashResponse(18); // Current usage is 18
      const result = await canConsumeImages("user123", 5);
      expect(result).toBe(false); // 18 + 5 = 23 > 20
    });

    test("returns true when exactly at limit", async () => {
      mockUpstashResponse(15); // Current usage is 15
      const result = await canConsumeImages("user123", 5);
      expect(result).toBe(true); // 15 + 5 = 20 <= 20
    });

    test("handles null/undefined redis response as zero", async () => {
      mockUpstashResponse(null);
      const result = await canConsumeImages("user123", 10);
      expect(result).toBe(true); // 0 + 10 = 10 <= 20
    });

    test("uses correct redis key with date", async () => {
      mockUpstashResponse(0);
      await canConsumeImages("user123", 5);

      const today = new Date();
      const expectedKey = `quota:user123:${today.getUTCFullYear()}-${String(today.getUTCMonth() + 1).padStart(2, "0")}-${String(today.getUTCDate()).padStart(2, "0")}`;

      expect(mockFetch).toHaveBeenCalledWith(
        expect.stringContaining(encodeURIComponent(expectedKey)),
        expect.any(Object)
      );
    });

    test("throws error when Upstash not configured", async () => {
      delete process.env.UPSTASH_REDIS_REST_URL;
      await expect(canConsumeImages("user123", 5)).rejects.toThrow("Upstash Redis not configured");
    });

    test("respects custom daily limit from env", async () => {
      process.env.USER_FREE_IMAGES_PER_DAY = "50";
      mockUpstashResponse(45);
      const result = await canConsumeImages("user123", 10);
      expect(result).toBe(false); // 45 + 10 = 55 > 50
    });
  });

  describe("consumeImages", () => {
    test("does nothing when count is zero or negative", async () => {
      await consumeImages("user123", 0);
      await consumeImages("user123", -5);
      expect(mockFetch).not.toHaveBeenCalled();
    });

    test("increments quota and sets expiry", async () => {
      mockUpstashResponse("OK");
      await consumeImages("user123", 5);

      // Should call INCRBY and EXPIRE
      expect(mockFetch).toHaveBeenCalledTimes(2);

      // Check INCRBY call
      const incrbyCall = (mockFetch.mock.calls[0] as any)[0];
      expect(incrbyCall).toContain("INCRBY");
      expect(incrbyCall).toContain("5");

      // Check EXPIRE call (24 hours = 86400 seconds)
      const expireCall = (mockFetch.mock.calls[1] as any)[0];
      expect(expireCall).toContain("EXPIRE");
      expect(expireCall).toContain("86400");
    });

    test("uses correct authorization header", async () => {
      mockUpstashResponse("OK");
      await consumeImages("user123", 5);

      expect(mockFetch).toHaveBeenCalledWith(
        expect.any(String),
        expect.objectContaining({
          headers: expect.objectContaining({
            Authorization: "Bearer test-token",
          }),
        })
      );
    });

    test("propagates Upstash errors", async () => {
      mockUpstashError(500, "Internal Server Error");
      await expect(consumeImages("user123", 5)).rejects.toThrow("Upstash 500");
    });
  });

  describe("canStartJob", () => {
    test("returns true when under running job limit", async () => {
      mockUpstashResponse(1); // Current running: 1
      const result = await canStartJob("user123");
      expect(result).toBe(true); // 1 < 2
    });

    test("returns false when at running job limit", async () => {
      mockUpstashResponse(2); // Current running: 2
      const result = await canStartJob("user123");
      expect(result).toBe(false); // 2 >= 2
    });

    test("returns false when exceeding running job limit", async () => {
      mockUpstashResponse(5); // Current running: 5
      const result = await canStartJob("user123");
      expect(result).toBe(false); // 5 >= 2
    });

    test("handles null/undefined redis response as zero", async () => {
      mockUpstashResponse(null);
      const result = await canStartJob("user123");
      expect(result).toBe(true); // 0 < 2
    });

    test("uses correct redis key", async () => {
      mockUpstashResponse(0);
      await canStartJob("user123");

      expect(mockFetch).toHaveBeenCalledWith(
        expect.stringContaining("jobsrun%3Auser123"),
        expect.any(Object)
      );
    });

    test("respects custom max running jobs from env", async () => {
      process.env.USER_MAX_RUNNING_JOBS = "5";
      mockUpstashResponse(4);
      const result = await canStartJob("user123");
      expect(result).toBe(true); // 4 < 5
    });
  });

  describe("incRunning", () => {
    test("increments running counter and sets expiry", async () => {
      mockUpstashResponse("OK");
      await incRunning("user123");

      // Should call INCR and EXPIRE
      expect(mockFetch).toHaveBeenCalledTimes(2);

      // Check INCR call
      const incrCall = (mockFetch.mock.calls[0] as any)[0];
      expect(incrCall).toContain("INCR");
      expect(incrCall).toContain("jobsrun");

      // Check EXPIRE call (2 hours = 7200 seconds)
      const expireCall = (mockFetch.mock.calls[1] as any)[0];
      expect(expireCall).toContain("EXPIRE");
      expect(expireCall).toContain("7200");
    });

    test("uses correct redis key", async () => {
      mockUpstashResponse("OK");
      await incRunning("user123");

      expect(mockFetch).toHaveBeenCalledWith(
        expect.stringContaining("jobsrun%3Auser123"),
        expect.any(Object)
      );
    });
  });

  describe("decRunning", () => {
    test("decrements running counter", async () => {
      mockUpstashResponse("OK");
      await decRunning("user123");

      expect(mockFetch).toHaveBeenCalledTimes(1);

      // Check DECR call
      const decrCall = (mockFetch.mock.calls[0] as any)[0];
      expect(decrCall).toContain("DECR");
      expect(decrCall).toContain("jobsrun");
    });

    test("catches and logs errors without throwing", async () => {
      const consoleWarnSpy = jest.spyOn(console, "warn").mockImplementation();
      mockUpstashError(500, "Error");

      await expect(decRunning("user123")).resolves.not.toThrow();
      expect(consoleWarnSpy).toHaveBeenCalledWith(
        "Failed to decrement running quota",
        expect.any(Error)
      );

      consoleWarnSpy.mockRestore();
    });

    test("uses correct redis key", async () => {
      mockUpstashResponse("OK");
      await decRunning("user123");

      expect(mockFetch).toHaveBeenCalledWith(
        expect.stringContaining("jobsrun%3Auser123"),
        expect.any(Object)
      );
    });
  });

  describe("Integration scenarios", () => {
    test("full workflow: check, consume, start job", async () => {
      // Check if can consume images
      mockUpstashResponse(10);
      expect(await canConsumeImages("user123", 5)).toBe(true);

      // Consume images
      mockUpstashResponse("OK");
      await consumeImages("user123", 5);

      // Check if can start job
      mockUpstashResponse(1);
      expect(await canStartJob("user123")).toBe(true);

      // Start job
      mockUpstashResponse("OK");
      await incRunning("user123");

      expect(mockFetch).toHaveBeenCalled();
    });

    test("handles quota exceeded gracefully", async () => {
      mockUpstashResponse(20);
      expect(await canConsumeImages("user123", 1)).toBe(false);
      
      // Should not consume if check fails
      jest.clearAllMocks();
      // Don't call consumeImages if canConsume returns false
    });
  });
});
